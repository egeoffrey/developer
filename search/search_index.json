{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome, eGeoffrey Developer! This website is intended to provide useful information regarding eGeoffrey to developers or users willing to understand a bit more regarding the software architecture and internals as well as looking for guidelines on how to contribute to extend eGeoffrey and make it better. If you are not a developer and instead looking for the User Manual and the Getting Started guide, please visit https://docs.egeoffrey.com . Index This portal is organized in the following sections: Create a New Package - step-by-step instructions on how to extend eGeoffrey and contribute with custom functionalities Contribute to Existing Packages - how to enhance or fix an existing eGeoffrey package eGeoffrey Architecture - understand more about eGeoffrey's design principles, its architecture and the main components eGeoffrey SDK - how to leverage eGeoffrey SDK's reusable functions and pre-configured runtime environment for easily developing and building your custom packages Not enough? Do you still need additional information or help? Visit the Development section on our Forum !","title":"Home"},{"location":"#welcome-egeoffrey-developer","text":"This website is intended to provide useful information regarding eGeoffrey to developers or users willing to understand a bit more regarding the software architecture and internals as well as looking for guidelines on how to contribute to extend eGeoffrey and make it better. If you are not a developer and instead looking for the User Manual and the Getting Started guide, please visit https://docs.egeoffrey.com .","title":"Welcome, eGeoffrey Developer!"},{"location":"#index","text":"This portal is organized in the following sections: Create a New Package - step-by-step instructions on how to extend eGeoffrey and contribute with custom functionalities Contribute to Existing Packages - how to enhance or fix an existing eGeoffrey package eGeoffrey Architecture - understand more about eGeoffrey's design principles, its architecture and the main components eGeoffrey SDK - how to leverage eGeoffrey SDK's reusable functions and pre-configured runtime environment for easily developing and building your custom packages","title":"Index"},{"location":"#not-enough","text":"Do you still need additional information or help? Visit the Development section on our Forum !","title":"Not enough?"},{"location":"architecture/components/","text":"Core Components The following minimum set of packages are required to make eGeoffrey running and are automatically deployed by the installer: egeoffrey-gateway : the message bus through which all the modules communicate egeoffrey-database : the database which stores information about your sensors egeoffrey-controller : the beating heart of eGeoffrey which takes care, among the other of orchestrating your sensors, running your rules, etc. egeoffrey-gui : the web user interface through which you can interact with eGeoffrey and configure it With this minimal configuration, egeoffrey-gateway provides the message bus all the other packages will use to communicate with each other, egeoffrey-controller takes care of running most of eGeoffrey's core tasks storing configured sensors' values into the database provided by egeoffrey-database and finally egeoffrey-gui offers the web interface for both end users and eGeoffrey admins. Extending eGeoffrey With just core components eGoeffrey will be alive but just sitting there and doing nothing. Things get more interesting as you start adding additional packages. Packages that can extend eGeoffrey are grouped in three categories: notification packages, which can be used to trigger notifications upon specific events (e.g. email, slack, etc.) interaction packages, which can be used to interact with eGeoffrey (e.g. with a microphone, through slack, etc.) service packages, which provides an interface with a specific device, protocol or service which are used to collect measures and values for your sensors or control your actuator (e.g. a weather service API, a zigbee device, etc.) A Marketplace has been made available through the eGeoffrey's web interface or the website https://marketplace.egeoffrey.com to search for additional packages. Installation takes place through the egeoffrey-cli utility which is installed on your system. If you develop a new package. this can be easily made available to other users by publishing it on the eGeoffrey Marketplace.","title":"eGeoffrey Components"},{"location":"architecture/components/#core-components","text":"The following minimum set of packages are required to make eGeoffrey running and are automatically deployed by the installer: egeoffrey-gateway : the message bus through which all the modules communicate egeoffrey-database : the database which stores information about your sensors egeoffrey-controller : the beating heart of eGeoffrey which takes care, among the other of orchestrating your sensors, running your rules, etc. egeoffrey-gui : the web user interface through which you can interact with eGeoffrey and configure it With this minimal configuration, egeoffrey-gateway provides the message bus all the other packages will use to communicate with each other, egeoffrey-controller takes care of running most of eGeoffrey's core tasks storing configured sensors' values into the database provided by egeoffrey-database and finally egeoffrey-gui offers the web interface for both end users and eGeoffrey admins.","title":"Core Components"},{"location":"architecture/components/#extending-egeoffrey","text":"With just core components eGoeffrey will be alive but just sitting there and doing nothing. Things get more interesting as you start adding additional packages. Packages that can extend eGeoffrey are grouped in three categories: notification packages, which can be used to trigger notifications upon specific events (e.g. email, slack, etc.) interaction packages, which can be used to interact with eGeoffrey (e.g. with a microphone, through slack, etc.) service packages, which provides an interface with a specific device, protocol or service which are used to collect measures and values for your sensors or control your actuator (e.g. a weather service API, a zigbee device, etc.) A Marketplace has been made available through the eGeoffrey's web interface or the website https://marketplace.egeoffrey.com to search for additional packages. Installation takes place through the egeoffrey-cli utility which is installed on your system. If you develop a new package. this can be easily made available to other users by publishing it on the eGeoffrey Marketplace.","title":"Extending eGeoffrey"},{"location":"architecture/configuration/","text":"The configuration of any eGeoffrey module is managed by controller/config . This is because in a distributed deployment you may want to keep the configuration of all your components in a single location, regardless the modules originating the file and which one is using them. Publish the Configuration As anything else in eGeoffrey, also configuration distribution is happening through the message bus. This allows modules to subscribe to the configuration they are expecting and configuration changes handled without the need to restart the module since it will receive a configuration callback once an updated file is re-published. Upon startup, the controller/config reads out all the files in the config directory and publishes them on MQTT with the same structure and according to these principles: The config module has zero-knowledge about which module needs which file and which settings each file has to have. This is up to the receiving module Configuration files are in a YAML format Subdirectories make up the topic structure. The filename will be the last part of the topic, with the extension removed (e.g. a file in subdir/dir/filename.yml will be published in the topic subdir/dir/filename Files beginning with dot (.) or without a .yml extension are ignored Configuration is published under a CONF command. This prevents conflicts with other messages When using gateway protocol v1, publishing have \"retain\" flag set so the configuration is always available for the module service subscribing that topic (no matter when it starts, it will receive the configuration straight away). If using protocol v2, the configuration is not retained on the message bus and the SDK takes care of distributing the configurations required by each module The latest version only of each configuration file is kept on the bus Receive the Configuration Any module which needs a configuration file, has to subscribe to a specific topic. The eGeoffrey SDK makes this easier, providing the following functions from within the Module class: add_configuration_listener(args, version=None, wait_for_it=False) : add a listener for the given configuration request (will call on_configuration()) add_request_listener(from_module, command, args) : add a listener for the messages addressed to this module (will call on_message()) add_broadcast_listener(from_module, command, args) : add a listener for broadcasted messages from the given module (will call on_message()) add_inspection_listener(from_module, to_module, command, args) : add a listener for intercepting messages from a given module to a given module (will call on_message()) remove_listener(topic) : remove a topic previously subscribed Once the listener is added, the configuration will be received in the on_configuration(message) callback. Validate the Configuration controller/config just ensure the file is in a valid YAML format but is up to the receiving module to validate the file. eGeoffrey SDK makes available is_valid_configuration(settings, configuration) to ensure all the items of an array of settings are included in the configuration object provided. Returning false from a configuration message received by on_configuration(message) will instruct the module to just ignore the file. Required Configuration Files There are situations in which a module needs a specific configuration file before starting. For example the database module has to know where the database is before connecting. When a configuration listener is added with wait_for_it set to true, the module will not start (hence on_start() will not be called) until ALL the required configurations have been received. Default Configuration Since controller/config has no knowledge of which modules are running and which versions they are at, it cannot bring any default configuration with it, which is instead delegated to individual packages. Developers can add a default_config directory in the root of their package directory and copy there any configuration file they want, with the same format of standard configuration files. In this way, when the package starts, the watchdog module will read the content of all the files in this directory, attach it to the package manifest and publish it. The config module subscribed for receiving new manifests being published so when this happens and if default_config is in the manifest, it re-create the entire directory structure locally (unless the given file already exists) before publishing the new files as part of eGeoffrey's configuration. This approach allows to: delegate developers to control of their own configuration files centralize the configuration even if the components can live in different places distribute out-of-the-box contents together with each package Save/Update a Configuration Through specific messages, the config module can save new or updated configuration files. To avoid reloading the entire configuration upon each change, the config module builds up an index of all the files which is saved in the message bus so to re-publish only new or updated files. When a file is deleted, a message with null payload is published to the bus.","title":"Configuration Management"},{"location":"architecture/configuration/#publish-the-configuration","text":"As anything else in eGeoffrey, also configuration distribution is happening through the message bus. This allows modules to subscribe to the configuration they are expecting and configuration changes handled without the need to restart the module since it will receive a configuration callback once an updated file is re-published. Upon startup, the controller/config reads out all the files in the config directory and publishes them on MQTT with the same structure and according to these principles: The config module has zero-knowledge about which module needs which file and which settings each file has to have. This is up to the receiving module Configuration files are in a YAML format Subdirectories make up the topic structure. The filename will be the last part of the topic, with the extension removed (e.g. a file in subdir/dir/filename.yml will be published in the topic subdir/dir/filename Files beginning with dot (.) or without a .yml extension are ignored Configuration is published under a CONF command. This prevents conflicts with other messages When using gateway protocol v1, publishing have \"retain\" flag set so the configuration is always available for the module service subscribing that topic (no matter when it starts, it will receive the configuration straight away). If using protocol v2, the configuration is not retained on the message bus and the SDK takes care of distributing the configurations required by each module The latest version only of each configuration file is kept on the bus","title":"Publish the Configuration"},{"location":"architecture/configuration/#receive-the-configuration","text":"Any module which needs a configuration file, has to subscribe to a specific topic. The eGeoffrey SDK makes this easier, providing the following functions from within the Module class: add_configuration_listener(args, version=None, wait_for_it=False) : add a listener for the given configuration request (will call on_configuration()) add_request_listener(from_module, command, args) : add a listener for the messages addressed to this module (will call on_message()) add_broadcast_listener(from_module, command, args) : add a listener for broadcasted messages from the given module (will call on_message()) add_inspection_listener(from_module, to_module, command, args) : add a listener for intercepting messages from a given module to a given module (will call on_message()) remove_listener(topic) : remove a topic previously subscribed Once the listener is added, the configuration will be received in the on_configuration(message) callback.","title":"Receive the Configuration"},{"location":"architecture/configuration/#validate-the-configuration","text":"controller/config just ensure the file is in a valid YAML format but is up to the receiving module to validate the file. eGeoffrey SDK makes available is_valid_configuration(settings, configuration) to ensure all the items of an array of settings are included in the configuration object provided. Returning false from a configuration message received by on_configuration(message) will instruct the module to just ignore the file.","title":"Validate the Configuration"},{"location":"architecture/configuration/#required-configuration-files","text":"There are situations in which a module needs a specific configuration file before starting. For example the database module has to know where the database is before connecting. When a configuration listener is added with wait_for_it set to true, the module will not start (hence on_start() will not be called) until ALL the required configurations have been received.","title":"Required Configuration Files"},{"location":"architecture/configuration/#default-configuration","text":"Since controller/config has no knowledge of which modules are running and which versions they are at, it cannot bring any default configuration with it, which is instead delegated to individual packages. Developers can add a default_config directory in the root of their package directory and copy there any configuration file they want, with the same format of standard configuration files. In this way, when the package starts, the watchdog module will read the content of all the files in this directory, attach it to the package manifest and publish it. The config module subscribed for receiving new manifests being published so when this happens and if default_config is in the manifest, it re-create the entire directory structure locally (unless the given file already exists) before publishing the new files as part of eGeoffrey's configuration. This approach allows to: delegate developers to control of their own configuration files centralize the configuration even if the components can live in different places distribute out-of-the-box contents together with each package","title":"Default Configuration"},{"location":"architecture/configuration/#saveupdate-a-configuration","text":"Through specific messages, the config module can save new or updated configuration files. To avoid reloading the entire configuration upon each change, the config module builds up an index of all the files which is saved in the message bus so to re-publish only new or updated files. When a file is deleted, a message with null payload is published to the bus.","title":"Save/Update a Configuration"},{"location":"architecture/definitions/","text":"Provided below are a list of key concept around eGeoffrey's internals: A module is defined as the code of a functional unit. e.g. the component that periodically checks if your rules are triggering (alerter) is a module. The component which queries the weather service for the current temperature is another module, etc. each module belongs to a scope , defined as a group of modules. The following scopes are identified: controller : modules part of the eGeoffrey core (e.g. interact with the database, collect data from sensors, run alerting rules, etc.) interaction : modules responsible for interacting with the user (e.g. through Slack, a microphone, etc.) notification : modules responsible for notifying the user about something (e.g. through email, slack, text messages, etc.) service : modules responsible for interfacing with a specific device or protocol to retrieve data or control actuators (e.g. a weather service, a webcam, a MySensors device, Zigbee protocol, etc.) gui : modules responsible for running the eGeoffrey GUI system : reserved for system components (e.g. the watchdog modules) modules' naming convention is <scope_name>/<module_name> so e.g. valid names are controller/alerter , service/image , etc. A module may live or not in an independent container each individual module connects independently to the message bus and can communicate with the other only through it (even if living just aside) A package is defined as one or more modules built together into a Docker image each package has a manifest file describing what's inside it usually maps to a Github repository packages' naming convention is egeoffrey-<package_name> where package_name can be: a built-in eGeoffrey component (e.g. egeoffrey-database ) a package mapping to single module (e.g. egeoffrey-service-image ) a collection of multiple modules (e.g. egeoffrey-collection-raspberrypi ) A gateway is the eGeoffrey component through which all the modules connect to and exchange information by leveraging the publish&subscribe approach. In a nutshell, eGeoffrey is made of different components (modules) which communicates through a message bus (the gateway) and distributed as Docker images (packages).","title":"Definitions"},{"location":"architecture/deployment/","text":"A lot of effort has been made to allow eGeoffrey to be deployed many different ways. Its distributed architecture made of isolated components interacting through a shared message bus, allows to position each component on any platform and wherever you need. Local Deployment The simplest and most common deployment options is on-prem, running on a Raspberry Pi device or your house server. In this scenario all the components (controller, gui, gateway, database, notification modules, etc.) are running within the same environment interacting through the message bus. This of course is transparent to the user. The egeoffrey-cli takes care of managing the docker runtime environment by creating a single bridge network where all the containers live. Remote Deployment You may think of distributing eGeoffrey's components in different places according to your needs. A potential scenario is with a server hosted by some Cloud provider running eGeoffrey's components which do not need to interact with local devices you may have at home and the others running on-prem. Since the message bus is shared (hosted in the cloud in this case), the user will enjoy the same user experience, without even the need to open ports on the firewall or other complex configurations. If the Cloud environment is publicly accessible, we strongly encourage to secure the eGeoffrey gateway by enabling authentication and ACLs and if possible SSL. All the other components do not need to be further secured since living hidden behind the scene. If you are familiar with Docker Swarm or Kubernetes you have to leverage them manually since egeoffrey-cli only supports running with docker-compose . Distributed Deployment This is an extension of the previously described remote deployment but instead of having a central location and some components running on your house you can have components distributed in multiple geographically distributed locations (e.g. collect data from multiple houses). As far as all the houses are connecting to the same gateway, it will work nicely eGeoffrey-as-a-service Another variant of a distributed deployed is by offering eGeoffrey as a service. In this scenario the deployment would be the same as described above with additional considerations you can read in the Multi-Tenancy page.","title":"Deployment Options"},{"location":"architecture/deployment/#local-deployment","text":"The simplest and most common deployment options is on-prem, running on a Raspberry Pi device or your house server. In this scenario all the components (controller, gui, gateway, database, notification modules, etc.) are running within the same environment interacting through the message bus. This of course is transparent to the user. The egeoffrey-cli takes care of managing the docker runtime environment by creating a single bridge network where all the containers live.","title":"Local Deployment"},{"location":"architecture/deployment/#remote-deployment","text":"You may think of distributing eGeoffrey's components in different places according to your needs. A potential scenario is with a server hosted by some Cloud provider running eGeoffrey's components which do not need to interact with local devices you may have at home and the others running on-prem. Since the message bus is shared (hosted in the cloud in this case), the user will enjoy the same user experience, without even the need to open ports on the firewall or other complex configurations. If the Cloud environment is publicly accessible, we strongly encourage to secure the eGeoffrey gateway by enabling authentication and ACLs and if possible SSL. All the other components do not need to be further secured since living hidden behind the scene. If you are familiar with Docker Swarm or Kubernetes you have to leverage them manually since egeoffrey-cli only supports running with docker-compose .","title":"Remote Deployment"},{"location":"architecture/deployment/#distributed-deployment","text":"This is an extension of the previously described remote deployment but instead of having a central location and some components running on your house you can have components distributed in multiple geographically distributed locations (e.g. collect data from multiple houses). As far as all the houses are connecting to the same gateway, it will work nicely","title":"Distributed Deployment"},{"location":"architecture/deployment/#egeoffrey-as-a-service","text":"Another variant of a distributed deployed is by offering eGeoffrey as a service. In this scenario the deployment would be the same as described above with additional considerations you can read in the Multi-Tenancy page.","title":"eGeoffrey-as-a-service"},{"location":"architecture/design/","text":"There are hundreds of home automation suites around and dozens of new solutions made available every single day. So why yet another piece of software? First of all there are two big categories of software. Closed-source, vendor-dependent products which are good with a specific make and you don't know how much will cost in the future and until when will be supported and open frameworks , which can interact with a number of different devices, protocols, etc. but still keeping the same user experience. Whoever is looking for something in this latter category (where eGeoffrey lives) could have very different and peculiar requirements. This is because you have to deal with different technologies and formats and present data in a number of ways. eGeoffrey was born with simplicity and flexibility in mind. Start configuring the sensors you want to collect data from by leveraging the different services available (e.g. to collect weather statistics, images from the Internet, your GPS position, etc.). Once you have the data, what will be presented in the web interface is completely up to you. You can draw your own pages, configure the widgets and statistics that will be presented in the order you like the most. From the interface your actuators can be controlled as well. You can also easily create rules to be automatically alerted whenever a specific situation is taking place, triggering a number of notifications means. This is a summary of the foundational principles that have been taken into account during the design of eGeoffrey, key capabilities and definitions you would need to know before starting developing. The main themes eGeoffrey's design was intended to address, in order of priority are the following: Robust and Modular Architecture : ensure new releases and required 3rd party libraries run smoothly regardless of the hosting operating system and the libraries installed and new components can be easily added. Run anywhere : ability to run on different platforms, including cloud based providers with the ability to locate different components in different places Multi-tenancy : ability to host multiple \"houses\" within the same eGeoffrey instance with authentication/authorization mechanisms Modern and easy to use UI : to guide the users with dedicated wizards throughout the configuration process and with the ability to display any information in multiple ways to meet users' needs. From a technical standpoint, those have been the development principles guiding the direction of eGeoffrey: Pack dependencies together with the software This avoids conflicts and/or missing packages issues Docker ( https://www.docker.com/ ) solves this problem since the application and all the dependencies are packed together Simplifying the deployment since the user needs to just pull the image from Docker Hub Updates are simplified as well leveraging docker's tags Rollbacks are as easy as starting a container Docker works fine even on Raspberry pi and has no problem with the little resources available Architecture based on micro-services : Micro services (e.g. Docker images) can be easily updated, stopped or restarted Users can easily contribute by adding a new component in the form of a micro service without the need to get into the code too much Micro services can be tested in an easier way Micro services can easily scale by adding additional containers Micro services can be easily added/removed to eGeoffrey (plug&play) Interaction of the different components takes place through a message bus : More flexible and powerful of traditional REST APIs This applies to the web gui as well which would benefit from realtime updates upon subscribed topics A lightweight pub/sub message bus like MQTT allows services in different locations to interact The message bus helps overcoming any NAT constraint The message bus allows multi-tasking (e.g. a request is sent to the bus and the service goes on) resulting in a more robust architecture and less delays MQTT retain and QoS capabilities helps in increasing resiliency Components have zero-knowledge about the others : they leverage the message bus to do discovery and configuration allows adding a new pieces without any change to core code thus facilitating user to contribute each component follows its own development cycle, no dependencies","title":"Design Principles"},{"location":"architecture/multi-tenancy/","text":"Having the ability to run multiple houses is key and a differentiator for eGeoffrey. This allows to easily host multiple users within the same environment or even deliver eGeoffrey-as-a-service to multiple house. To ensure maximum isolation, confidentiality of the data and flexibility to run different versions of the software for each house, the following approach has been adopted. Gateway The gateway component is supposed to be common among multiple houses. The topic structure allows to easily isolate logically individual houses (provided of course they have a different house_id ) Since the same house_id and passcode (username and password for the gateway) is used for all the modules belonging to the same house, the service provider has add a single user to the gateway to provide a new house The gateway's ACLs can prevent a user to see what's happening inside a different house. Additionally ACLs can be set based on username so the service provider needs to maintain only a single ACL with the username wildcard Modules Every house will run its own dedicated modules (including the Web UI) connecting to a shared gateway. This choice has been taken to achieve the following: Code simplicity since every module should keep otherwise a map between the house and its entire runtime environment and challenges in distinguishing between shared modules and house-dedicated modules in the communication Users can restart their own components without affecting all the houses which could have suffered a downtime otherwise Possibility for managing entitlements for every house (e.g. a given house can have only a portion of the services of another house) Ability to measure how much resources a house is using - useful in a consumption-based scenario Simplify debug and troubleshoot (how to understand which house is causing an excessive load on a shared service) Scalability (e.g. how to scale a shared service with all the houses having the same resources available) Multi-version support Isolation and increased security Database Since Redis does not provide robust authentication/authorization mechanisms for this scenario, either use a different redis database for each house or use a single, shared MongoDB database. In this scenario each database map to a different house. It is up to the admin to provision users to MongoDB, ideally assigning a dbAdmin role only for the assigned database (e.g. the house_id) to the user.","title":"Multi-Tenancy"},{"location":"architecture/multi-tenancy/#gateway","text":"The gateway component is supposed to be common among multiple houses. The topic structure allows to easily isolate logically individual houses (provided of course they have a different house_id ) Since the same house_id and passcode (username and password for the gateway) is used for all the modules belonging to the same house, the service provider has add a single user to the gateway to provide a new house The gateway's ACLs can prevent a user to see what's happening inside a different house. Additionally ACLs can be set based on username so the service provider needs to maintain only a single ACL with the username wildcard","title":"Gateway"},{"location":"architecture/multi-tenancy/#modules","text":"Every house will run its own dedicated modules (including the Web UI) connecting to a shared gateway. This choice has been taken to achieve the following: Code simplicity since every module should keep otherwise a map between the house and its entire runtime environment and challenges in distinguishing between shared modules and house-dedicated modules in the communication Users can restart their own components without affecting all the houses which could have suffered a downtime otherwise Possibility for managing entitlements for every house (e.g. a given house can have only a portion of the services of another house) Ability to measure how much resources a house is using - useful in a consumption-based scenario Simplify debug and troubleshoot (how to understand which house is causing an excessive load on a shared service) Scalability (e.g. how to scale a shared service with all the houses having the same resources available) Multi-version support Isolation and increased security","title":"Modules"},{"location":"architecture/multi-tenancy/#database","text":"Since Redis does not provide robust authentication/authorization mechanisms for this scenario, either use a different redis database for each house or use a single, shared MongoDB database. In this scenario each database map to a different house. It is up to the admin to provision users to MongoDB, ideally assigning a dbAdmin role only for the assigned database (e.g. the house_id) to the user.","title":"Database"},{"location":"architecture/security/","text":"The design choice has been to have a (strong) layer enforced by the MQTT broker for every module belonging to the same house and second (weaker) layer to handle users within the same house implemented within the application. This avoids creating a new MQTT user for every new user in the house since eGeoffrey has no access to MQTT configuration allow implementing additional capabilities delegating to e.g. house admin users complete control over their user base, setting/resetting passwords etc. Despite users' security is enforced only at the application layer, this is still only related to the isolated house Modules Each module connecting to message bus has to know at least the gateway location and optionally how to authenticate against it. This means the authentication and authorization logic lives outside eGeoffrey since it is in charge of the message bus. Authentication Since eGeoffrey's main use case is when deployed in a secure, controlled environment (e.g. local LAN), by default no authentication is enforced Each module authenticates against MQTT using the house_id as username and an optional password all the modules share the same credentials to allow ease of use but still maximum isolation between houses For an open MQTT broker with no restrictions, authentication works in the same way (username/password is not enforced by the broker) An admin interested in hosting multiple houses has to configure a new user in MQTT only once when a new house is added Advanced users can configure the MQTT broker to enforce authentication with username/password, client certificate or client_id prefix. All of those are supported by eGeoffrey Authorization by default no ACL is enforced; however eGeoffrey's SDK silently discard any message whose recipient is a different house the one is taking care of An admin interested in isolating multiple houses running on the same broker can enforce a single, simple ACL which will restrict access based on username (e.g. the house_id): pattern readwrite egeoffrey/+/%u/# Confidentiality By default, modules connect to the gateway over an insecure websocket connection over port 443/tcp If you need to ensure confdentiality of the data transmitted by the modules to the gateway, either enable SSL to the websocket listener or make them connecting to the secure MQTTS port 8883/tcp. To do so, set in your .env file: EGEOFFREY_GATEWAY_PORT=8883 EGEOFFREY_GATEWAY_TRANSPORT=\"tcp\" EGEOFFREY_GATEWAY_SSL=1 Users This is referring to users operating within the same house accessing the web GUI. Authentication the web gui tries first to connect to the MQTT broker residing at the URL the user is visiting without authentication (the default). If it fails (broker elsewhere? username/password required?) shows up a login page requesting the user the gateway hostname, port, house_id, house passocde and, username and password. The latter (username and password) are stored in the gui/users.yml configuration file. Password is not secured (clear-text) since this is belonging to the weaker layer of security and authentication is happening on the client side. Users can be managed entirely from within the eGeoffrey web interface. By default the following two users are available: guest / <no password> : guest user (belongs to the `guests group) admin / admin : admin user (belongs to the house_admins and egeoffrey_admins groups) Authorization eGeoffrey defines groups in the gui/groups.yml configuration file. A user can be part of multiple groups. The following groups are defined but a user can add additional groups: guests: can access all the pages of the web interface but the admin pages house_admins: can access all the pages of the web interface as well as configure the house, its sensors and rules egeoffrey_admins: can access all the pages of the web interface, configure the house and manage eGeoffrey (list installed packages and modules, review logs, access the marketplace, etc) Authorization is enforced client-side in the web interface admin users can restrict access to individual widgets or entire pages by granting access only to specific groups Confidentiality By default, the web gui application connect to the gateway over an insecure websocket connection over port 443/tcp If you need to ensure confidentiality of the data transmitted by the modules to the gateway, enable SSL to the websocket listener (mqtts is not supported by the javascript library). Ensure the certificate to be valid Database By design every house is supposed to be hosted on a dedicated Redis database server. Password authentication, if needed, is supported in this configuration. If MongoDB is used as a backend database, a single database can host multiple houses (this scenario would not be possible with Redis). Authentication with username and password is supported in this configuration. It is up to the admin to provision users to MongoDB, ideally assigning a dbAdmin role only for the assigned database (e.g. the house_id) to the user.","title":"Security"},{"location":"architecture/security/#modules","text":"Each module connecting to message bus has to know at least the gateway location and optionally how to authenticate against it. This means the authentication and authorization logic lives outside eGeoffrey since it is in charge of the message bus.","title":"Modules"},{"location":"architecture/security/#authentication","text":"Since eGeoffrey's main use case is when deployed in a secure, controlled environment (e.g. local LAN), by default no authentication is enforced Each module authenticates against MQTT using the house_id as username and an optional password all the modules share the same credentials to allow ease of use but still maximum isolation between houses For an open MQTT broker with no restrictions, authentication works in the same way (username/password is not enforced by the broker) An admin interested in hosting multiple houses has to configure a new user in MQTT only once when a new house is added Advanced users can configure the MQTT broker to enforce authentication with username/password, client certificate or client_id prefix. All of those are supported by eGeoffrey","title":"Authentication"},{"location":"architecture/security/#authorization","text":"by default no ACL is enforced; however eGeoffrey's SDK silently discard any message whose recipient is a different house the one is taking care of An admin interested in isolating multiple houses running on the same broker can enforce a single, simple ACL which will restrict access based on username (e.g. the house_id): pattern readwrite egeoffrey/+/%u/#","title":"Authorization"},{"location":"architecture/security/#confidentiality","text":"By default, modules connect to the gateway over an insecure websocket connection over port 443/tcp If you need to ensure confdentiality of the data transmitted by the modules to the gateway, either enable SSL to the websocket listener or make them connecting to the secure MQTTS port 8883/tcp. To do so, set in your .env file: EGEOFFREY_GATEWAY_PORT=8883 EGEOFFREY_GATEWAY_TRANSPORT=\"tcp\" EGEOFFREY_GATEWAY_SSL=1","title":"Confidentiality"},{"location":"architecture/security/#users","text":"This is referring to users operating within the same house accessing the web GUI.","title":"Users"},{"location":"architecture/security/#authentication_1","text":"the web gui tries first to connect to the MQTT broker residing at the URL the user is visiting without authentication (the default). If it fails (broker elsewhere? username/password required?) shows up a login page requesting the user the gateway hostname, port, house_id, house passocde and, username and password. The latter (username and password) are stored in the gui/users.yml configuration file. Password is not secured (clear-text) since this is belonging to the weaker layer of security and authentication is happening on the client side. Users can be managed entirely from within the eGeoffrey web interface. By default the following two users are available: guest / <no password> : guest user (belongs to the `guests group) admin / admin : admin user (belongs to the house_admins and egeoffrey_admins groups)","title":"Authentication"},{"location":"architecture/security/#authorization_1","text":"eGeoffrey defines groups in the gui/groups.yml configuration file. A user can be part of multiple groups. The following groups are defined but a user can add additional groups: guests: can access all the pages of the web interface but the admin pages house_admins: can access all the pages of the web interface as well as configure the house, its sensors and rules egeoffrey_admins: can access all the pages of the web interface, configure the house and manage eGeoffrey (list installed packages and modules, review logs, access the marketplace, etc) Authorization is enforced client-side in the web interface admin users can restrict access to individual widgets or entire pages by granting access only to specific groups","title":"Authorization"},{"location":"architecture/security/#confidentiality_1","text":"By default, the web gui application connect to the gateway over an insecure websocket connection over port 443/tcp If you need to ensure confidentiality of the data transmitted by the modules to the gateway, enable SSL to the websocket listener (mqtts is not supported by the javascript library). Ensure the certificate to be valid","title":"Confidentiality"},{"location":"architecture/security/#database","text":"By design every house is supposed to be hosted on a dedicated Redis database server. Password authentication, if needed, is supported in this configuration. If MongoDB is used as a backend database, a single database can host multiple houses (this scenario would not be possible with Redis). Authentication with username and password is supported in this configuration. It is up to the admin to provision users to MongoDB, ideally assigning a dbAdmin role only for the assigned database (e.g. the house_id) to the user.","title":"Database"},{"location":"architecture/startup/","text":"In eGeoffrey, what eventually the end user runs is a set of Docker images, one for each installed package. To avoid the user to run individual containers manually with tons of options, eGeoffrey execution is orchestrated through docker-compose . As an additional level of abstraction, a tool called egeoffrely-cli which is deployed upon installation is provided to install new package, manage intalled packages as well as starting and stopping eGeoffrey without the need to edit any configuration file by hand. The CLI will take care of editing eGeoffrey's configuration for you and customizing the container according to the author's instructions. Each package has its own development lifecycle and should not have any requirement on other packages. This principle allow development and contributions to be quick and easy and immediately available to all the users without requiring any change to eGeoffrey's core code. Startup Configuration Which packages to run and instructions on how to connect to the Gateway,are stored in the following two files: docker-compose.yml : which contains a list of packages that are run upon startup .env : which contains environment variables common to all the packages (e.g. gateway location, house id, etc.) Those reside in the directory you chose to install eGeoffrey into. Once again, you don't need to edit the files manually: the installer or at a later stage egeoffrey-cli , will guide through the process. Since by definition Docker containers are stateless, packages which need a persistent storage are configured to store their files (configuration, logs, etc.) into the data folder, residing once again in the directory you chose to install eGeoffrey into. Starting eGeoffrey When running sudo egeoffrey-cli house start , each of the configured eGeoffrey package installed by the user will be run in independent Docker containers.","title":"Startup Process"},{"location":"architecture/startup/#startup-configuration","text":"Which packages to run and instructions on how to connect to the Gateway,are stored in the following two files: docker-compose.yml : which contains a list of packages that are run upon startup .env : which contains environment variables common to all the packages (e.g. gateway location, house id, etc.) Those reside in the directory you chose to install eGeoffrey into. Once again, you don't need to edit the files manually: the installer or at a later stage egeoffrey-cli , will guide through the process. Since by definition Docker containers are stateless, packages which need a persistent storage are configured to store their files (configuration, logs, etc.) into the data folder, residing once again in the directory you chose to install eGeoffrey into.","title":"Startup Configuration"},{"location":"architecture/startup/#starting-egeoffrey","text":"When running sudo egeoffrey-cli house start , each of the configured eGeoffrey package installed by the user will be run in independent Docker containers.","title":"Starting eGeoffrey"},{"location":"architecture/versioning/","text":"Versioning your Package Across eGeoffrey, there isn't a global version number. Each package has its own version which evolves independently from the others and from eGeoffrey's core components. Each package is characterized by the following information related to its version, all contained within the manifest file: branch : the branch to which the code belongs to. This information is used as a channel for updates (for example developers can allow users to select between a stable and development branch and they will always receive the latest version of the given channel). It is required to have a master branch updated with the latest stable version. version : the major version of the package (e.g. 1.0, 1.1, etc.). The Docker image of the latest release of each major version will persist so users can always downgrade to the latest version of each major release. revision : the revision number (e.g. 21, 22, etc.) is incremented at EVERY new commit (automatically when developers use egeoffre-cli repo commit ). The overall version of a package is then in the format <version>-<revision> (e.g. 1.0-22 ) and is independent accross branches. A user is notified a new version is available if the latest revision and/or version for the branch the user has installed ( master by default) are greater than the one of the package currently installed. When starting to develop your own package, the first commit will be version 1.0-1 in the master branch and at every commit the revision number will be increased. Creating a new Branch If for example you are developing the new version of your package, don't want end users to use to automatically download this version until fully tested but still you want to allow a limited set of beta testers to use it, you may want to create a new branch (e.g. called development) which will act as an independent update channel. Developers can create a new branch by running egeoffre-cli repo branch <branch_name> (e.g. egeoffre-cli repo branch development ). The utility automatically updates the manifest file with the new branch name and checkout into it. Every new commit will be then against this branch and only user \"subscribed\" to that branch will get the latest version. If a end user needs to install a package belonging to a branch different than master , this has to be made explicit with egeoffrey-cli package install package:branch (e.g. egeoffrey-cli package install egeoffrey-service-example:development ). Once selected, a branch this can only be changed manually by modifying the docker-compose.yml file. If your development cycle is finished and e.g. you want to promote the code in the development branch into the master you can run egeoffrey-cli repo merge . This will merge all the changes done in the development branch into master. At the next commit, your master package will include all those changes. Creating a new Version Developers can switch to a new version by running egeoffre-cli repo version <version> (e.g. egeoffre-cli repo version 1.1 ). The utility automatically updates the manifest file with the new version. Creating a new Revision The revision number is incremented automatically at every commit when running egeoffre-cli repo commit .","title":"Versioning"},{"location":"architecture/versioning/#versioning-your-package","text":"Across eGeoffrey, there isn't a global version number. Each package has its own version which evolves independently from the others and from eGeoffrey's core components. Each package is characterized by the following information related to its version, all contained within the manifest file: branch : the branch to which the code belongs to. This information is used as a channel for updates (for example developers can allow users to select between a stable and development branch and they will always receive the latest version of the given channel). It is required to have a master branch updated with the latest stable version. version : the major version of the package (e.g. 1.0, 1.1, etc.). The Docker image of the latest release of each major version will persist so users can always downgrade to the latest version of each major release. revision : the revision number (e.g. 21, 22, etc.) is incremented at EVERY new commit (automatically when developers use egeoffre-cli repo commit ). The overall version of a package is then in the format <version>-<revision> (e.g. 1.0-22 ) and is independent accross branches. A user is notified a new version is available if the latest revision and/or version for the branch the user has installed ( master by default) are greater than the one of the package currently installed. When starting to develop your own package, the first commit will be version 1.0-1 in the master branch and at every commit the revision number will be increased.","title":"Versioning your Package"},{"location":"architecture/versioning/#creating-a-new-branch","text":"If for example you are developing the new version of your package, don't want end users to use to automatically download this version until fully tested but still you want to allow a limited set of beta testers to use it, you may want to create a new branch (e.g. called development) which will act as an independent update channel. Developers can create a new branch by running egeoffre-cli repo branch <branch_name> (e.g. egeoffre-cli repo branch development ). The utility automatically updates the manifest file with the new branch name and checkout into it. Every new commit will be then against this branch and only user \"subscribed\" to that branch will get the latest version. If a end user needs to install a package belonging to a branch different than master , this has to be made explicit with egeoffrey-cli package install package:branch (e.g. egeoffrey-cli package install egeoffrey-service-example:development ). Once selected, a branch this can only be changed manually by modifying the docker-compose.yml file. If your development cycle is finished and e.g. you want to promote the code in the development branch into the master you can run egeoffrey-cli repo merge . This will merge all the changes done in the development branch into master. At the next commit, your master package will include all those changes.","title":"Creating a new Branch"},{"location":"architecture/versioning/#creating-a-new-version","text":"Developers can switch to a new version by running egeoffre-cli repo version <version> (e.g. egeoffre-cli repo version 1.1 ). The utility automatically updates the manifest file with the new version.","title":"Creating a new Version"},{"location":"architecture/versioning/#creating-a-new-revision","text":"The revision number is incremented automatically at every commit when running egeoffre-cli repo commit .","title":"Creating a new Revision"},{"location":"architecture/core/controller/","text":"The eGeoffrey Controller The eGeoffrey controller manages the configuration of all the modules and coordinates sensors and run alerting rules. The controller itself is logically split in different modules: controller/alerter : keep running the configured rules which would trigger notifications controller/chatbot : interactive chatbot service controller/config : stores configuration files on behalf of all the modules and makes them available controller/db : connects to the database and runs queries on behalf of other modules controller/hub : hub for collecting new measures from sensors controller/logger : takes care of collecting the logs from all the local and remote modules, storing them in the database and printing them out Each module may required a configuration file whose content is detailed on https://github.com/egeoffrey/egeoffrey-controller API Each controller module interacts with any other module through the message bus, despite where it resides; for this reason a structured communication protocol has been developed. A user doesn't need to know anything about it since hidden under the hood. Even a developer doesn't need to get into these details since the SDK is taking care of this low level communication. For each module, the main <command> and their purposes will be listed below for both inbound and outbound requests (for the latter the recipient module is also listed): controller/alerter : inbound: RUN/<rule_id> : run manually a given rule outbound: controller/db - GET*/<sensor_id> : request the database for sensors' data controller/hub - SET/<sensor_id> : set the value to a sensor as an action to execute when a rule trigger controller/hub - POLL/<sensor_id> : poll the sensor for a new value as an action to execute when a rule trigger controller/alerter - RUN/<sensor_id> : action to execute when a rule trigger controller/db SAVE_ALERT/<severity> : save notification to db */* - NOTIFY/<severity>/<rule_id> : notify output modules controller/db - PURGE_ALERTS : periodically purge old alerts from db controller/chatbot : inbound: ASK : receive request from other modules outbound: controller/alerter - RUN/<rule_id> : run a rule controller/db - GET/<sensor_id> : request value of a sensor to the database controller/config : inbound: SAVE/<config_id> : save a new/updated configuration file DELETE/<config_id> : delete a configuration file controller/db : inbound: SAVE/<sensor_id> : save a new measure for a sensor SAVE_ALERT/<severity> : save a new alert CALC_HOUR_STATS/<sensor_id> : calculate hourly aggregated stats CALC_DAY_STATS/<sensor_id> : calculate daily aggregated stats PURGE_SENSOR/<sensor_id> : delete old measures from db PURGE_ALERTS : purge old alerts from db DELETE_SENSOR/<sensor_id> : delete from the db the data associated to a sensor GET/<sensor_id> : return measures from the db GET_ELAPSED/<sensor_id> : return the elapsed time since the measure was taken GET_TIMESTAMP/<sensor_id> : return the timestamp of the measure GET_DISTANCE/<sensor_id> : return the distance from the measure GET_POSITION_LABEL/<sensor_id> : return the label associated to a position GET_POSITION_TEXT/<sensor_id> : return the text associated to the position GET_SCHEDULE/<sensor_id> : return the schedule of a calendar data format GET_COUNT/<sensor_id> : return the number of measures of a given timeframe outbound: */* - SAVED/<sensor_id> : notify everybody a new measure has been saved controller/hub : inbound: IN/<sensor_id> : receive a new value from a sensor (solicited or unsolicited) coming from the associated service POLL/<sensor_id> : requested to invoke the service associated to the sensor SET/<sensor_id> : asked to set a new value to a sensor outbound: service/<service_name> - IN/<sensor_id> : invoke the service associated to a sensor to pull out a new value service/<service_name> - OUT/<sensor_id> : trigger an action to an actuator controller/db - CALC_HOUR_STATS/<sensor_id> / CALC_DAY_STATS/<sensor_id> : periodically calculate aggregates controller/db - PURGE_SENSOR/<sensor_id> : periodically purge old data controller/db - SAVE/<sensor_id> : save new measures controller/logger : inbound: LOG/<severity> : receive new log messages from all the modules Advanced Settings The following additional environment variables can control specific advanced settings: EGEOFFREY_DATABASE_HOSTNAME : override the database hostname from the configuration file EGEOFFREY_DATABASE_PORT : override the database port from the configuration file EGEOFFREY_DATABASE_NAME : override the database name/number from the configuration file EGEOFFREY_DATABASE_USERNAME : override the database username from the configuration file EGEOFFREY_DATABASE_PASSWORD : override the database password from the configuration file EGEOFFREY_CONFIG_DIR : override the directory where the configuration resides (default to config ) EGEOFFREY_CONFIG_FORCE_RELOAD : force realoading the configuration from the filesystem (default to 0 ) EGEOFFREY_CONFIG_FORCE_RELOAD_TIMEOUT : when reloading the configuraiton, for how many seconds waiting for the old settings already in the bus to clear up (default to 10 ) EGEOFFREY_CONFIG_ACCEPT_DEFAULTS : accept default configuration files provided by other packages in the manifest file (default to 1 )","title":"Controller"},{"location":"architecture/core/controller/#the-egeoffrey-controller","text":"The eGeoffrey controller manages the configuration of all the modules and coordinates sensors and run alerting rules. The controller itself is logically split in different modules: controller/alerter : keep running the configured rules which would trigger notifications controller/chatbot : interactive chatbot service controller/config : stores configuration files on behalf of all the modules and makes them available controller/db : connects to the database and runs queries on behalf of other modules controller/hub : hub for collecting new measures from sensors controller/logger : takes care of collecting the logs from all the local and remote modules, storing them in the database and printing them out Each module may required a configuration file whose content is detailed on https://github.com/egeoffrey/egeoffrey-controller","title":"The eGeoffrey Controller"},{"location":"architecture/core/controller/#api","text":"Each controller module interacts with any other module through the message bus, despite where it resides; for this reason a structured communication protocol has been developed. A user doesn't need to know anything about it since hidden under the hood. Even a developer doesn't need to get into these details since the SDK is taking care of this low level communication. For each module, the main <command> and their purposes will be listed below for both inbound and outbound requests (for the latter the recipient module is also listed): controller/alerter : inbound: RUN/<rule_id> : run manually a given rule outbound: controller/db - GET*/<sensor_id> : request the database for sensors' data controller/hub - SET/<sensor_id> : set the value to a sensor as an action to execute when a rule trigger controller/hub - POLL/<sensor_id> : poll the sensor for a new value as an action to execute when a rule trigger controller/alerter - RUN/<sensor_id> : action to execute when a rule trigger controller/db SAVE_ALERT/<severity> : save notification to db */* - NOTIFY/<severity>/<rule_id> : notify output modules controller/db - PURGE_ALERTS : periodically purge old alerts from db controller/chatbot : inbound: ASK : receive request from other modules outbound: controller/alerter - RUN/<rule_id> : run a rule controller/db - GET/<sensor_id> : request value of a sensor to the database controller/config : inbound: SAVE/<config_id> : save a new/updated configuration file DELETE/<config_id> : delete a configuration file controller/db : inbound: SAVE/<sensor_id> : save a new measure for a sensor SAVE_ALERT/<severity> : save a new alert CALC_HOUR_STATS/<sensor_id> : calculate hourly aggregated stats CALC_DAY_STATS/<sensor_id> : calculate daily aggregated stats PURGE_SENSOR/<sensor_id> : delete old measures from db PURGE_ALERTS : purge old alerts from db DELETE_SENSOR/<sensor_id> : delete from the db the data associated to a sensor GET/<sensor_id> : return measures from the db GET_ELAPSED/<sensor_id> : return the elapsed time since the measure was taken GET_TIMESTAMP/<sensor_id> : return the timestamp of the measure GET_DISTANCE/<sensor_id> : return the distance from the measure GET_POSITION_LABEL/<sensor_id> : return the label associated to a position GET_POSITION_TEXT/<sensor_id> : return the text associated to the position GET_SCHEDULE/<sensor_id> : return the schedule of a calendar data format GET_COUNT/<sensor_id> : return the number of measures of a given timeframe outbound: */* - SAVED/<sensor_id> : notify everybody a new measure has been saved controller/hub : inbound: IN/<sensor_id> : receive a new value from a sensor (solicited or unsolicited) coming from the associated service POLL/<sensor_id> : requested to invoke the service associated to the sensor SET/<sensor_id> : asked to set a new value to a sensor outbound: service/<service_name> - IN/<sensor_id> : invoke the service associated to a sensor to pull out a new value service/<service_name> - OUT/<sensor_id> : trigger an action to an actuator controller/db - CALC_HOUR_STATS/<sensor_id> / CALC_DAY_STATS/<sensor_id> : periodically calculate aggregates controller/db - PURGE_SENSOR/<sensor_id> : periodically purge old data controller/db - SAVE/<sensor_id> : save new measures controller/logger : inbound: LOG/<severity> : receive new log messages from all the modules","title":"API"},{"location":"architecture/core/controller/#advanced-settings","text":"The following additional environment variables can control specific advanced settings: EGEOFFREY_DATABASE_HOSTNAME : override the database hostname from the configuration file EGEOFFREY_DATABASE_PORT : override the database port from the configuration file EGEOFFREY_DATABASE_NAME : override the database name/number from the configuration file EGEOFFREY_DATABASE_USERNAME : override the database username from the configuration file EGEOFFREY_DATABASE_PASSWORD : override the database password from the configuration file EGEOFFREY_CONFIG_DIR : override the directory where the configuration resides (default to config ) EGEOFFREY_CONFIG_FORCE_RELOAD : force realoading the configuration from the filesystem (default to 0 ) EGEOFFREY_CONFIG_FORCE_RELOAD_TIMEOUT : when reloading the configuraiton, for how many seconds waiting for the old settings already in the bus to clear up (default to 10 ) EGEOFFREY_CONFIG_ACCEPT_DEFAULTS : accept default configuration files provided by other packages in the manifest file (default to 1 )","title":"Advanced Settings"},{"location":"architecture/core/database/","text":"The eGeoffrey Database To provide a controlled and structured access to the data, the only module which can access the database is controller/db . Queries have to be submitted in the same way eGeoffrey's modules traditionally communicates, e.g. through the message bus. controller/db will take care of executing the query returning the result back. To ensure a decent user experience, a pre-configured database image is provided in the package egeoffrey-database , which is automatically deployed by the installer. Redis has been selected as the preferred option for storing eGeoffrey's data. This is because it is light and especially when running on a Raspberry Pi, does not stress the SD card too much with continuous writing operations. The Redis database will accept connections on the following port: 6379/tcp As an alternative option, MongoDB is also supported by controller/db and is delivered by the egeoffrey-database-mongodb package. However, this options is intended for a complex ISP scenario when hosting multiple houses and Redis approach to keep everything in memory would come with a high cost. For a standalone, raspberrypi-based installation, Redis is always the way to go. The MongoDB database will accept connections on the following port: 27017/tcp Database Schema eGeoffreys stores the following information in the database: Sensors' data : each sensor has one of more keys in the database in the format eGeoffrey/sensors/<sensor_id>/<aggregation> . Since eGeoffrey has the capability to automatically calculate aggregated statistics (e.g. hourly and daily averages, max, min, etc.), this is appended at the end (e.g. eGeoffrey/sensors/temperature/day/avg ) Notifications : whenever a rule triggers and a notification is sent out, the database keep track of it. This also includes every new value when is set to a sensor. The format of the key is eGeoffrey/alerts/<severity> Logs : eGeoffreys logs are stored in the database as well. The format of the key is `eGeoffrey/logs/ Version : eGeoffreys database schema version which is used for upgrading the database schema when needed. The format key `eGeoffrey/version The house_id is not used as part of the database schema for two reasons: each house is supposed to have its dedicated database renaming the house_id would not require renaming all the keys","title":"Database"},{"location":"architecture/core/database/#the-egeoffrey-database","text":"To provide a controlled and structured access to the data, the only module which can access the database is controller/db . Queries have to be submitted in the same way eGeoffrey's modules traditionally communicates, e.g. through the message bus. controller/db will take care of executing the query returning the result back. To ensure a decent user experience, a pre-configured database image is provided in the package egeoffrey-database , which is automatically deployed by the installer. Redis has been selected as the preferred option for storing eGeoffrey's data. This is because it is light and especially when running on a Raspberry Pi, does not stress the SD card too much with continuous writing operations. The Redis database will accept connections on the following port: 6379/tcp As an alternative option, MongoDB is also supported by controller/db and is delivered by the egeoffrey-database-mongodb package. However, this options is intended for a complex ISP scenario when hosting multiple houses and Redis approach to keep everything in memory would come with a high cost. For a standalone, raspberrypi-based installation, Redis is always the way to go. The MongoDB database will accept connections on the following port: 27017/tcp","title":"The eGeoffrey Database"},{"location":"architecture/core/database/#database-schema","text":"eGeoffreys stores the following information in the database: Sensors' data : each sensor has one of more keys in the database in the format eGeoffrey/sensors/<sensor_id>/<aggregation> . Since eGeoffrey has the capability to automatically calculate aggregated statistics (e.g. hourly and daily averages, max, min, etc.), this is appended at the end (e.g. eGeoffrey/sensors/temperature/day/avg ) Notifications : whenever a rule triggers and a notification is sent out, the database keep track of it. This also includes every new value when is set to a sensor. The format of the key is eGeoffrey/alerts/<severity> Logs : eGeoffreys logs are stored in the database as well. The format of the key is `eGeoffrey/logs/ Version : eGeoffreys database schema version which is used for upgrading the database schema when needed. The format key `eGeoffrey/version The house_id is not used as part of the database schema for two reasons: each house is supposed to have its dedicated database renaming the house_id would not require renaming all the keys","title":"Database Schema"},{"location":"architecture/core/gateway/","text":"The eGeoffrey Gateway Communication between modules takes place ONLY through a message bus and Mosquitto MQTT has been selected as the preferred option. To ensure a decent user experience, a pre-configured MQTT broker is provided in the package egeoffrey-gateway , which is automatically deployed by the installer. Modules connecting to the gateway can connect to port: 1883/tcp : mqtt tcp protocol 8883/tcp : mqtts tcp protocol 443/tcp : websocket protocol As an alternative option, VerneMQ is also supported and is delivered by the egeoffrey-gateway-vernemq package. However, this options is intended for a complex ISP scenario when hosting multiple houses since allows more granular access control and monitoring capabilities. Communication To allow a structured communication among the modules, a topic naming convention is defined as follows: egeoffrey/<protocol_version>/<house_id>/<source_scope>/<source_module>/<to_scope>/<to_module>/<command>/<args> This approach allows to: have 1:1 communication between modules without overlapping and without knowing if a module exists or not. have 1:n communication, with destination that can be set to \"*\" (e.g. notification sent through different channels published once and different output services subscribing to the notification topic) Each module can publish only on its own topic and should subscribe other modules' topics E.g. controller/hub request temperature to service/openweathermap publishes the request on egeoffrey/v1/1/controller/hub/service/openweathermap/IN/<sensor_id> and subscribe to egeoffrey/v1/+/service/+/controller/hub/# so to receive responses from all the modules command helps distinguishing among different requests in a structured way args can be used as a sort of sub-request controller modules (eGeoffrey's core component) have zero knowledge about the services and their names, they just subscribes to the output of any service This allows adding a new service without any change to core code house_id allows having multiple houses running on the same gateway and optionally setting ALCs to isolate houses/users one from the other An protocol_version string allows different versions communicating through the same bus without interfering payload for each message is structured in a JSON format. The SDK provides an easy and simple way to deal with it by providing an abstraction of a message Gateway Protocol A gateway protocol is the way modules communicate to each other through the message bus provided by the eGeoffrey gateway. Please note, this is not something related to the MQTT gateway itself, rather the application layer built into the SDK and used by eGeoffrey components to interact. All the modules connecting to the gateway has to be configured with the same protocol for communication to take place. The gateway protocol in use is controlled by the EGEOFFREY_GATEWAY_VERSION variable which can be set also by egeoffrey-cli (e.g. egeoffrey-cli set_env EGEOFFREY_GATEWAY_VERSION <version> ) This is once again completely transparent for the user since the underlying SDK will take care of handling the entire process, once the gateway version is set. Version 1 Modules expect to find the entire configuration pinned (retained) on the message bus. This is perfectly fine for a local gateway but not ideal when using a Cloud Gateway because the whole configuration is supposed to be kept in memory and data of house no more in use are kept there forever, making the service not really scalable. Version 2 No configuration is unsolicited published to the bus by controller/config which will instead send the configuration over to every module requesting it. Version 2 requires packages be built against SDK >= v1.1, egeoffrey-controller >= v1.4 and egeoffrey-gui >= v1.4. Advanced Settings The following additional environment variables can control specific advanced settings: EGEOFFREY_GATEWAY_ACL : if ACLs on the gateway have to be enabled EGEOFFREY_GATEWAY_USERS : set users and passwords for accessing the gateway (in the format user1:password1\\nuser2:password2) Additionally an eGeoffrey gateway can be connected (briged) to a remote gateway so that messages sent on one broker will be propataged to another borker and viceversa: REMOTE_EGEOFFREY_GATEWAY_HOSTNAME : the hostname or ip address of the remote gateway REMOTE_EGEOFFREY_GATEWAY_PORT : the port of the remote gateway REMOTE_EGEOFFREY_GATEWAY_SSL : if the remote gateway supports SSL REMOTE_EGEOFFREY_ID : username for the remote gateway REMOTE_EGEOFFREY_PASSCODE : password for the remote gateway","title":"Gateway"},{"location":"architecture/core/gateway/#the-egeoffrey-gateway","text":"Communication between modules takes place ONLY through a message bus and Mosquitto MQTT has been selected as the preferred option. To ensure a decent user experience, a pre-configured MQTT broker is provided in the package egeoffrey-gateway , which is automatically deployed by the installer. Modules connecting to the gateway can connect to port: 1883/tcp : mqtt tcp protocol 8883/tcp : mqtts tcp protocol 443/tcp : websocket protocol As an alternative option, VerneMQ is also supported and is delivered by the egeoffrey-gateway-vernemq package. However, this options is intended for a complex ISP scenario when hosting multiple houses since allows more granular access control and monitoring capabilities.","title":"The eGeoffrey Gateway"},{"location":"architecture/core/gateway/#communication","text":"To allow a structured communication among the modules, a topic naming convention is defined as follows: egeoffrey/<protocol_version>/<house_id>/<source_scope>/<source_module>/<to_scope>/<to_module>/<command>/<args> This approach allows to: have 1:1 communication between modules without overlapping and without knowing if a module exists or not. have 1:n communication, with destination that can be set to \"*\" (e.g. notification sent through different channels published once and different output services subscribing to the notification topic) Each module can publish only on its own topic and should subscribe other modules' topics E.g. controller/hub request temperature to service/openweathermap publishes the request on egeoffrey/v1/1/controller/hub/service/openweathermap/IN/<sensor_id> and subscribe to egeoffrey/v1/+/service/+/controller/hub/# so to receive responses from all the modules command helps distinguishing among different requests in a structured way args can be used as a sort of sub-request controller modules (eGeoffrey's core component) have zero knowledge about the services and their names, they just subscribes to the output of any service This allows adding a new service without any change to core code house_id allows having multiple houses running on the same gateway and optionally setting ALCs to isolate houses/users one from the other An protocol_version string allows different versions communicating through the same bus without interfering payload for each message is structured in a JSON format. The SDK provides an easy and simple way to deal with it by providing an abstraction of a message","title":"Communication"},{"location":"architecture/core/gateway/#gateway-protocol","text":"A gateway protocol is the way modules communicate to each other through the message bus provided by the eGeoffrey gateway. Please note, this is not something related to the MQTT gateway itself, rather the application layer built into the SDK and used by eGeoffrey components to interact. All the modules connecting to the gateway has to be configured with the same protocol for communication to take place. The gateway protocol in use is controlled by the EGEOFFREY_GATEWAY_VERSION variable which can be set also by egeoffrey-cli (e.g. egeoffrey-cli set_env EGEOFFREY_GATEWAY_VERSION <version> ) This is once again completely transparent for the user since the underlying SDK will take care of handling the entire process, once the gateway version is set.","title":"Gateway Protocol"},{"location":"architecture/core/gateway/#version-1","text":"Modules expect to find the entire configuration pinned (retained) on the message bus. This is perfectly fine for a local gateway but not ideal when using a Cloud Gateway because the whole configuration is supposed to be kept in memory and data of house no more in use are kept there forever, making the service not really scalable.","title":"Version 1"},{"location":"architecture/core/gateway/#version-2","text":"No configuration is unsolicited published to the bus by controller/config which will instead send the configuration over to every module requesting it. Version 2 requires packages be built against SDK >= v1.1, egeoffrey-controller >= v1.4 and egeoffrey-gui >= v1.4.","title":"Version 2"},{"location":"architecture/core/gateway/#advanced-settings","text":"The following additional environment variables can control specific advanced settings: EGEOFFREY_GATEWAY_ACL : if ACLs on the gateway have to be enabled EGEOFFREY_GATEWAY_USERS : set users and passwords for accessing the gateway (in the format user1:password1\\nuser2:password2) Additionally an eGeoffrey gateway can be connected (briged) to a remote gateway so that messages sent on one broker will be propataged to another borker and viceversa: REMOTE_EGEOFFREY_GATEWAY_HOSTNAME : the hostname or ip address of the remote gateway REMOTE_EGEOFFREY_GATEWAY_PORT : the port of the remote gateway REMOTE_EGEOFFREY_GATEWAY_SSL : if the remote gateway supports SSL REMOTE_EGEOFFREY_ID : username for the remote gateway REMOTE_EGEOFFREY_PASSCODE : password for the remote gateway","title":"Advanced Settings"},{"location":"architecture/core/gui/","text":"The eGeoffrey Web UI The eGeoffrey gui package provides a modern and responsive web interface to both access your data and manage eGeoffrey. Despite some peculiarities, its logic is the same as any other module, that is connects to the message bus, receive its configuration and deliver its services to the end user. In this way the GUI does not rely on any REST API interface and is completely static: the entire logic is coming from the message bus and the house-specific configuration. The package egeoffrey-gui includes a single module: gui/webserver : which runs a nginx webserver hosting the static pages of the GUI Once the user connects to the GUI, if the house is configured to require authentication, a login screen is presented and the following information is requested: Gateway hostname, port and, if SSL is enabled (where is the gateway and how to connect to it) House ID and Passcode (how to authenticate against the gateway) Username and password (which web interface user to login to). By default the following two users are available: guest / <no password> : guest user admin / admin : admin user Advanced Settings The following additional environment variables can control specific advanced settings: EGEOFFREY_LOGIN_DISCLAIMER : an optional login disclaimer to be shown on top of the login screen EGEOFFREY_LANGUAGE : default language of the web interface EGEOFFREY_GUI_* : override any EGEOFFREY_* variable set in the gui module","title":"GUI"},{"location":"architecture/core/gui/#the-egeoffrey-web-ui","text":"The eGeoffrey gui package provides a modern and responsive web interface to both access your data and manage eGeoffrey. Despite some peculiarities, its logic is the same as any other module, that is connects to the message bus, receive its configuration and deliver its services to the end user. In this way the GUI does not rely on any REST API interface and is completely static: the entire logic is coming from the message bus and the house-specific configuration. The package egeoffrey-gui includes a single module: gui/webserver : which runs a nginx webserver hosting the static pages of the GUI Once the user connects to the GUI, if the house is configured to require authentication, a login screen is presented and the following information is requested: Gateway hostname, port and, if SSL is enabled (where is the gateway and how to connect to it) House ID and Passcode (how to authenticate against the gateway) Username and password (which web interface user to login to). By default the following two users are available: guest / <no password> : guest user admin / admin : admin user","title":"The eGeoffrey Web UI"},{"location":"architecture/core/gui/#advanced-settings","text":"The following additional environment variables can control specific advanced settings: EGEOFFREY_LOGIN_DISCLAIMER : an optional login disclaimer to be shown on top of the login screen EGEOFFREY_LANGUAGE : default language of the web interface EGEOFFREY_GUI_* : override any EGEOFFREY_* variable set in the gui module","title":"Advanced Settings"},{"location":"develop/contribute/","text":"eGeoffrey follows a decentralized appraoch meaning each package is associated to a GitHub repository which is owned by a user. So to enhance or fix an existing package, you would need to: Go and visit the Github repository where the package resides (also available in the manifest file of the package) Fork the repository Do the necessary changes Submit a PR (Pull Request) to the author The author will take care of validating your contribution, merging the content, building and publishing a new version","title":"Contribute to Existing Packages"},{"location":"develop/develop/","text":"Edit your code by opening in your repository the file service/example.py (since in this example we are creating a \"service\" called \"example\") and implement the logic of your module within the SDK callbacks below: Define in on_init() what to do when the module is initialized (e.g. initializing variables, requesting configuration files, etc.) Define in on_start() what to do when the module is started after having received the required configuration files (e.g. connect to a serial port) For sensors configured in \"push\" mode, whatever process you are running it is supposed to associate incoming data with registered sensors and send to controller/hub a message with IN as \"command\" and the sensor_id as \"args\" with a payload \"value\" set to whatever value you want to associate to the sensor (e.g. its new measure) Optionally define in on_stop() what to do just before the module is shutting down (e.g. disconnect from a serial port) Define in on_configuration() what to do when receiving a new/updated configurations, if requested a configuration file in on_init() : If receiving a configuration file you directly manage (e.g. created by your module), check if needs to be updated since you don't know which version of your code it was previously running If implementing a \"service\", register/unregister the sensors associated with your module through register_sensor()/unregister_sensor() sensors configured in \"pull\" mode will be automatically scheduled based on their configuration Optionally define in on_message(message) what to do when receiving a new message from the bus For sensors configured as \"pull\", a message with command set to IN will be received containing the configuration of the sensor which needs to be polled. Your code is expected to reply to the message with a payload \"value\" set to whatever value you want to associate to the sensor (e.g. its new measure) For sensors configured as \"actuators\", a message with command set to OUT will be received containing the configuration of the sensor which needs to actuated upon. For notification modules only, define in on_notify() what to do when receiving a new notification Open and customize the manifest file : Edit the description of the package, the tags (space-separated), the icon and the description of the module Ensure the links to the repositories on GitHub and DockerHub are correct (format is <username>/<repository_name> ) If your module requires a configuration file (e.g. containing the serial port it has to connect to), add a module_configuration to your module providing its configuration directives. This will be used by the GUI to render the configuration wizard. If your module is a \"Service\", for each of \"pull\", \"push\", \"actuator\" mode (depending which mode the service supports) add a service_configuration providing the directives the GUI will use to render the wizard when a sensor is associated to this module Optionally add a container_config directive if you want to instruct egeoffrey-cli to customize the container configuration when installing the package (e.g. by mapping the physical serial port to the container) If for any reason you need to build against a specific version of the SDK, add a sdk_branch directive Customize the Dockerfile file in the root directory of your repository which will be used by the build process to create the the target Docker image which will ultimately responsible for running your code: Select the appropriate SDK base image in the FROM directive Point out any Python dependencies to be installed in the target cointainer ( RUN pip install <package_name> ) Point out any Operating System dependencies to be installed in the target cointainer (with apt-get or apk depending on the base image selected) Optionally add any customization to the target image with additional RUN directives Optionally add a file called docker-init.sh into $WORKDIR if you need to run any custom commands within the container just before starting your eGeoffrey module Optionally place any default configuration files in the default_config directory in YAML format with a yml extension (for more information see the Configuration Management page). Those will be retrieved by controller/config once your module connects to the gateway and saved with the other configuration files so please ensure to create them in a directory structure compliant with the configuration module. Commit the changes to your code with e.g. egeoffrey-cli repo commit \"<comment>\" . This will automatically: Commit the chances to the local repository Push the new code to the remote repository on GitHub Trigger a GitHub Action which will: Test your eGeoffrey module code Package it in a Docker image for multiple CPU architectures Publish the images to your Dockerhub account for distribution Verify the images are available in your DockerHub account. In case of failure in the build process, you should receive an email notification","title":"Develop & Build"},{"location":"develop/distribute/","text":"Ensure the latest source code of your package is in your own Github repository and the Docker image published to your Dockerhub account Request for your package to be published to the eGeoffrey Marketplace Go to https://github.com/egeoffrey/egeoffrey-marketplace/tree/master/marketplace Click on Create new file Name the file as your package name with a yml extension (e.g. egeoffrey-service-example.yml ) The file content should have a single line in the format github: <git_username>/<git_repository> Save the file; this will trigger a PR (Pull Request) Once your request will be merged, your package will be available for all the other eGeoffrey users! If you are releasing a new version of a package there is no need to repeat the procedure above: it is up the Marketplace to always provide the most up to date content","title":"Distribute the Package"},{"location":"develop/requirements/","text":"The following are required for becoming a proficient eGeoffrey developer: Docker docker-compose Git eGeoffrey CLI An account on GitHub An account on DockerHub A DockerHub Access Token An eGeoffrey test instance up and running A basic knowledge of eGeoffrey SDK Most of the tools above are usually already installed by the eGeoffrey installer.","title":"Requirements"},{"location":"develop/setup/","text":"Select which kind of eGeoffrey functionality you want to provide: notification to trigger notifications upon specific events (e.g. email, slack, etc.) interaction to interact with eGeoffrey (e.g. with a microphone, through slack, etc.) service to provide an interface with a specific device, protocol or service which are used to collect measures and values for your sensors or control your actuator (e.g. a weather service API, a zigbee device, etc.) Choose a name for the package you want to build (e.g. we are creating a \"service\" called \"example\") Create the local repository for hosting your code: Initialize a new, empty repository with egeoffrey-cli repo init service example <your_github_user> which will automatically: create a directory called egeoffrey-service-example create inside it the package directory structure and other supporting files ( .gitignore , .dockerignore , manifest.yml etc.) initialize the git repository configure the remote URL to Github Create the remote repository in your GitHub account, in this example it has to be called egeoffrey-service-example Always on GitHub, go to the \"Settings\" of your repository, click on \"Secrets\" and create a secret called DOCKERHUB_USERNAME storing your DockerHub username and DOCKERHUB_TOKEN storing the DockerHub access code previously created. This will be used by the build process to automatically push the images to DockerHub Go into the directory of your local repostiory and commit your code by running egeoffrey-cli repo commit \"First commit\" Ensure the source code has been pushed by visit your repository on GitHub Always in your repository, click \"Actions\" and ensure the \"Build and Publish eGeoffrey Package\" workflow is completed (showing up green, it could take a couple of minutes) Ensure the Docker images have been pushed to DockerHub by visiting your DockerHub account (for each supported CPU architecture two images are built, one named as branch and another named after the version number)","title":"Setting up the Environment"},{"location":"develop/test/","text":"If not already done, install the newly created package into your eGeoffrey test instance by running, from within the directory where eGeoffrey is installed, egeoffrey-cli install <path_to_your_package>/manifest.yml . This will install your package in eGeoffrey, even if not available yet in the Marketplace If instead the package is already installed, download the latest version by running sudo egeoffrey-cli package update egeoffrey-service-example (if the package is called egeoffrey-service-example) Start your package by running sudo egeoffrey-cli house start . You package will be downloaded and started Review the logs generated by eGeoffrey with egeoffrey-cli house logs / egeoffrey-cli house logs_tail or those generated by your package only with egeoffrey-cli house logs egeoffrey-service-example (if the package is called egeoffrey-service-example) Alternative testing procedure If going through the automatic development and building process is time consuming for you and you want to test small changes of your code step by step, you can run your module without the need to package it first. Additional Requirements Python (v2.7) eGeoffrey SDK Python dependencies ( pip install paho-mqtt requests tinynumpy pyyaml yq apscheduler ) Any Python library and/or operating system dependencies required for running your code installed eGeoffrey SDK ( git clone https://github.com/egeoffrey/egeoffrey-sdk ) Manually Running your code Add eGeoffrey SDK to your local repository with ln -s <egeoffrey_sdk_directory>/sdk <your_package_directory>/sdk . This will create a symbolic link to the eGeoffrey SDK Configure the runtime environment by setting the environment variables you need to ensure your code can connect to the eGeoffrey test instance. You need at least to set EGEOFFREY_GATEWAY_HOSTNAME and EGEOFFREY_MODULES Start your module by running python -m sdk.python.module.start","title":"Test your Code"},{"location":"develop/test/#alternative-testing-procedure","text":"If going through the automatic development and building process is time consuming for you and you want to test small changes of your code step by step, you can run your module without the need to package it first.","title":"Alternative testing procedure"},{"location":"develop/test/#additional-requirements","text":"Python (v2.7) eGeoffrey SDK Python dependencies ( pip install paho-mqtt requests tinynumpy pyyaml yq apscheduler ) Any Python library and/or operating system dependencies required for running your code installed eGeoffrey SDK ( git clone https://github.com/egeoffrey/egeoffrey-sdk )","title":"Additional Requirements"},{"location":"develop/test/#manually-running-your-code","text":"Add eGeoffrey SDK to your local repository with ln -s <egeoffrey_sdk_directory>/sdk <your_package_directory>/sdk . This will create a symbolic link to the eGeoffrey SDK Configure the runtime environment by setting the environment variables you need to ensure your code can connect to the eGeoffrey test instance. You need at least to set EGEOFFREY_GATEWAY_HOSTNAME and EGEOFFREY_MODULES Start your module by running python -m sdk.python.module.start","title":"Manually Running your code"},{"location":"develop/update/","text":"In eGeoffrey, each package has its own lifecycle, independent from the other components so there is no concept of an eGeoffrey update but each package can be updated individually. For this reason, when you want to release an updated version of your code, simply re-iterate the steps detailed in Develop & Build to publish an updated version of your package. Since a package is delivered as a Docker image, each version is a self-contained, stateless instance of your code, with all the required dependencies packed together. At every commit of your code, the revision number will be automatically increased. Please review the eGeoffrey Versioning page for more details on the versioning capabilities. End users will be notified a new version is available and will upgrade accordingly. An end user can update all the installed packages by running egeoffrey-cli package update or a given package with egeoffrey-cli package update <package_name> . A sudo egeoffrey-cli house start is then required to make the newly downloaded image up and running. There is no concept of automatic updates in eGeoffrey to prevent users from breaking up local dependencies they might have. Upgrading a Configuration File Despite each eGeoffrey package is stateless, it could require one of more configuration files to run. The controller/config module is reponsible configuration management and for storing the configuration file of EVERY eGeoffrey component but managing those files follows a decentrilized approach which is under the responsibility of the package the configuration file has been generated. If for example your module brings in a new configuration file, it will be also responsible to upgrade its content whenever required. To do so, each configuration file is associated with a \"schema version number\". The schema version is automatically added by the config module in the filename when saving the file (e.g. settings.1.yml with schema version set to 1 ) and is automatically added as metadata to the configuration when publishing it to the message bus. It is your module responsability, whenever receiving a configuration file, to: If the configuration file is \"managed\" by your module (e.g. its own configuration file), to check the schema version number and if required (e.g. the expected version number is higher than the file version number) update file's content and version by using the provided SDK's upgrade_config(filename, from_version, to_version, content) . If the configuration file is not managed by your module (e.g. a sensor or a rule), to ensure the schema version number is the one you expect and support","title":"Update your Code"},{"location":"develop/update/#upgrading-a-configuration-file","text":"Despite each eGeoffrey package is stateless, it could require one of more configuration files to run. The controller/config module is reponsible configuration management and for storing the configuration file of EVERY eGeoffrey component but managing those files follows a decentrilized approach which is under the responsibility of the package the configuration file has been generated. If for example your module brings in a new configuration file, it will be also responsible to upgrade its content whenever required. To do so, each configuration file is associated with a \"schema version number\". The schema version is automatically added by the config module in the filename when saving the file (e.g. settings.1.yml with schema version set to 1 ) and is automatically added as metadata to the configuration when publishing it to the message bus. It is your module responsability, whenever receiving a configuration file, to: If the configuration file is \"managed\" by your module (e.g. its own configuration file), to check the schema version number and if required (e.g. the expected version number is higher than the file version number) update file's content and version by using the provided SDK's upgrade_config(filename, from_version, to_version, content) . If the configuration file is not managed by your module (e.g. a sensor or a rule), to ensure the schema version number is the one you expect and support","title":"Upgrading a Configuration File"},{"location":"sdk/bootstrap/","text":"Any eGeoffrey code is started with the following command: python -m sdk.python.module.start Upon startup, a special module provided by the SDK called watchdog is executed. There will be only one watchdog for each package (each package can carry one or multiple modules). The watchdog, like any other module, connects to the gateway and does two things: Startup any module of the package in its own thread. Which module is part of the package is defined by the environment variable EGEOFFREY_MODULES which contains a list, comma separated of <scope_name>/<module_name> (e.g. controller/logger, controller/config ) since there are situations in which you may want to run the same module multiple times (e.g. you want to connect two speakers or you have two MySensors gateway), optional aliasing is allowed in the format <scope_name>/<module_name>=<alias> . In this way a module named <scope_name>/<alias> will be run based on the <scope_name>/<module_name> code Read all the files in the default_config directory Read the package' manifest file ( manifest.yml ) which contains information regarding the package, its version, the modules, their configuration, etc., append the default configuration files and publish it to the message bus so other components will know about these new components made available. Once done, the watchdog goes to sleep but will promptly respond in case a discover message is broadcasted (to which will respond with the list of modules it is currently managing) or to start/stop/restart/enable debug on the modules it is responsible for. Module Startup When your module is started by the watchdog, it connects to the message bus as well. This is done independently since each module is now aware where it is running and if there are other components part of the same package. What a module is supposed to do, is up to its developer and is controlled by what has been implemented in the different callbacks made available through the SDK such as: on_init() : which is called with the module is created and initialized by the watchdog on_start() : which is called when the module is fully configured (in case a specific configuration file is needed before starting) on_stop() : which is called when the module is shutting down before the watchdog has been requested to do so or because the entire package is stopped on_message(message) : which is called when a new message addressed to this module is coming in on_configuration(message) : which is called when a configuration file requested by the module is coming in","title":"The Bootstrap Process"},{"location":"sdk/bootstrap/#module-startup","text":"When your module is started by the watchdog, it connects to the message bus as well. This is done independently since each module is now aware where it is running and if there are other components part of the same package. What a module is supposed to do, is up to its developer and is controlled by what has been implemented in the different callbacks made available through the SDK such as: on_init() : which is called with the module is created and initialized by the watchdog on_start() : which is called when the module is fully configured (in case a specific configuration file is needed before starting) on_stop() : which is called when the module is shutting down before the watchdog has been requested to do so or because the entire package is stopped on_message(message) : which is called when a new message addressed to this module is coming in on_configuration(message) : which is called when a configuration file requested by the module is coming in","title":"Module Startup"},{"location":"sdk/configuration/","text":"User-generated code is not run directly. The eGeoffrey SDK, instead, takes care through a bootstrap process to accomplishes common setup functionalities before running it. The SDK and eventually any user-created eGeoffrey code is configured through environment variables instructing which module the package provides, where the eGeoffrey gateway is located and so on. Specifically, the following are the variables the SDK consumes during the bootstrap process: EGEOFFREY_GATEWAY_HOSTNAME : the hostname or ip address of the gateway (default to egeoffrey-gateway ) EGEOFFREY_GATEWAY_PORT : the port of the gateway (default to 443 ) EGEOFFREY_GATEWAY_TRANSPORT : the transport protocol for connecting to the gateway (default to websockets ) EGEOFFREY_GATEWAY_SSL : if the gateway supports SSL (default to 0 ) EGEOFFREY_GATEWAY_VERSION : the gateway protocol version to use (default to 1 ) EGEOFFREY_GATEWAY_CA_CERT : if SSL is enabled, the path of the Certification Authority certificate (default to /etc/ssl/certs ) EGEOFFREY_GATEWAY_CERTFILE : if the gateway enforce client certificate authentication, the path of the client certificate EGEOFFREY_GATEWAY_KEYFILE : if the gateway enforce client certificate authentication, the path of the certificate keyfile EGEOFFREY_GATEWAY_QOS_SUBSCRIBE : the QoS to use when subscribing a topic on the gateway (default to 2 ) EGEOFFREY_GATEWAY_QOS_PUBLISH : the QoS to use when publishing a message to the gateway (default to 2 ) EGEOFFREY_ID : your house identifier (default to house ) EGEOFFREY_PASSCODE : your house passcode (default empty) EGEOFFREY_MODULES comma separated list of the modules to run in the format <scope_name>/<module_name> (e.g. controller/logger, controller/config ) EGEOFFREY_DEBUG : enable debug (default 0 ) EGEOFFREY_VERBOSE : enable verbose debug (default 0 ) EGEOFFREY_LOGGING_LOCAL : print out log message to standard output (default 1 ) EGEOFFREY_LOGGING_REMOTE : send any log message through the message bus to controller/logger for central logging (default 1 ) EGEOFFREY_PERSISTENT_CLIENT : enable mqtt persistent connection These can be set manually by running the operating system command: export EGEOFFREY_GATEWAY_HOSTNAME=localhost Or, when running in a containerized environment, by passing them through the Docker .env o docker-compose.yml files.","title":"Configure the Environment"},{"location":"sdk/manifest/","text":"The Manifest File A manifest file has to be part of every eGeoffrey package. The manifest file is located in the root directory of the package and called manifest.yml . The manifest accomplishes different functions: Provides an overview of the package's contents, its version and the modules part of the package Includes default configuration files that will be automatically sent to controller/config upon startup Provides a link to the Github repository where the package resides so to allow checking if new versions are available Provide details for the presenting the package in the Marketplace Instruct egeoffrey-cli on how to customize the docker runtime environment for the service (e.g. mapping local volumes, exposing ports, etc.) For each module, provide a schema of the configuration file so to allow the GUI to build up the wizard For each service, provide a schema of the service configuration so to allow the GUI to build up the wizard when a sensor is associated to this service Manifest Schema (v2) The manifest contains the following information: manifest_schema : the number of the manifest schema package : the name of the package branch : the branch where the code belongs to version : the version of the package (e.g. 1.0, master, etc.) revision : the revision number (e.g. 22) github : the Github url in the format <username>/<repository> dockerhub : the Docker Hub url in the format <username>/<repository> tags : list of tags, separated by space icon : fontawesome icon for this package modules : an array of the modules available within the package. For each module: description : description of the module ( optional ) module_configuration : array representing the schema of the configuration file having the same name of the module that the gui will use to render the configuration wizard ( optional ) name : name of the setting (key) description : description of the setting format : format of the setting required : if required placeholder : placeholder text service_configuration : for each of pull , push , actuator (depending which mode the service supports), an array representing the schema of the service configuration request that the gui will use to render the wizard when a sensor is associated to this module ( optional ) name : name of the setting (key) description : description of the setting format : format of the setting required : if required placeholder : placeholder text container_config : object that egeoffrey-cli will merge with the docker-compose service definition minimum_sdk_version : the minimum version of the SDK (with or without revision) the package requires to run ( optional ) sdk_branch : the SDK version to build the package against (default to \"master\") arch : an array of architectures to build the package for (default to \"amd\", \"arm32v6\") When the watchdog reads a manifest file, before publishing it, it adds the following entries: default_config : mapping for each file in the default_config directory (if any) the file's content sdk : the SDK manifest file","title":"The Manifest File"},{"location":"sdk/manifest/#the-manifest-file","text":"A manifest file has to be part of every eGeoffrey package. The manifest file is located in the root directory of the package and called manifest.yml . The manifest accomplishes different functions: Provides an overview of the package's contents, its version and the modules part of the package Includes default configuration files that will be automatically sent to controller/config upon startup Provides a link to the Github repository where the package resides so to allow checking if new versions are available Provide details for the presenting the package in the Marketplace Instruct egeoffrey-cli on how to customize the docker runtime environment for the service (e.g. mapping local volumes, exposing ports, etc.) For each module, provide a schema of the configuration file so to allow the GUI to build up the wizard For each service, provide a schema of the service configuration so to allow the GUI to build up the wizard when a sensor is associated to this service","title":"The Manifest File"},{"location":"sdk/manifest/#manifest-schema-v2","text":"The manifest contains the following information: manifest_schema : the number of the manifest schema package : the name of the package branch : the branch where the code belongs to version : the version of the package (e.g. 1.0, master, etc.) revision : the revision number (e.g. 22) github : the Github url in the format <username>/<repository> dockerhub : the Docker Hub url in the format <username>/<repository> tags : list of tags, separated by space icon : fontawesome icon for this package modules : an array of the modules available within the package. For each module: description : description of the module ( optional ) module_configuration : array representing the schema of the configuration file having the same name of the module that the gui will use to render the configuration wizard ( optional ) name : name of the setting (key) description : description of the setting format : format of the setting required : if required placeholder : placeholder text service_configuration : for each of pull , push , actuator (depending which mode the service supports), an array representing the schema of the service configuration request that the gui will use to render the wizard when a sensor is associated to this module ( optional ) name : name of the setting (key) description : description of the setting format : format of the setting required : if required placeholder : placeholder text container_config : object that egeoffrey-cli will merge with the docker-compose service definition minimum_sdk_version : the minimum version of the SDK (with or without revision) the package requires to run ( optional ) sdk_branch : the SDK version to build the package against (default to \"master\") arch : an array of architectures to build the package for (default to \"amd\", \"arm32v6\") When the watchdog reads a manifest file, before publishing it, it adds the following entries: default_config : mapping for each file in the default_config directory (if any) the file's content sdk : the SDK manifest file","title":"Manifest Schema (v2)"},{"location":"sdk/overview/","text":"eGeoffrey SDK To avoid re-inventing the wheel every time, most of the common functionalities needed to make a module running have been integrated into the eGeoffrey SDK. Every eGeoffrey module has to be based on the SDK; eGeoffrey core components including the controller, the GUI, etc. are all based upon the same principle. eGeoffrey SDK is providing both a set of reusable functions for developing your eGeoffrey code AND a pre-configured runtime environment for easily build and publish your custom packages. Programming Languages The ambitious of eGeoffrey is to be multi-language whenever possible. For this reason the communication takes place through a language-agnostic message bus and common capabilities can be delivered through language-specific SDKs. A the time of writing the following languages are supported: Python: used by all the modules Javascript: used by the web interface Supported CPU Architectures The runtime environment of eGeoffrey SDK is available for both amd64 and arm32v6 CPU architectures so to allow developers to build their packages and provide the same functionalities for traditional computer/server (usually amd64 ) and IoT devices like a Raspberry Pi ( arm32v6 ).","title":"Overview"},{"location":"sdk/overview/#egeoffrey-sdk","text":"To avoid re-inventing the wheel every time, most of the common functionalities needed to make a module running have been integrated into the eGeoffrey SDK. Every eGeoffrey module has to be based on the SDK; eGeoffrey core components including the controller, the GUI, etc. are all based upon the same principle. eGeoffrey SDK is providing both a set of reusable functions for developing your eGeoffrey code AND a pre-configured runtime environment for easily build and publish your custom packages.","title":"eGeoffrey SDK"},{"location":"sdk/overview/#programming-languages","text":"The ambitious of eGeoffrey is to be multi-language whenever possible. For this reason the communication takes place through a language-agnostic message bus and common capabilities can be delivered through language-specific SDKs. A the time of writing the following languages are supported: Python: used by all the modules Javascript: used by the web interface","title":"Programming Languages"},{"location":"sdk/overview/#supported-cpu-architectures","text":"The runtime environment of eGeoffrey SDK is available for both amd64 and arm32v6 CPU architectures so to allow developers to build their packages and provide the same functionalities for traditional computer/server (usually amd64 ) and IoT devices like a Raspberry Pi ( arm32v6 ).","title":"Supported CPU Architectures"},{"location":"sdk/use/","text":"Developing against the SDK To leverage the SDK, this has to be accessible by your code. A sdk directory from the eGeoffrey SDK repository is expected to be in the root directory of the package. It includes the SDK for all the supported languages. When using eGeoffrey SDK pre-built runtime images, this action is not needed since the SDK and all its required dependencies are already included. To fully leverage eGeoffrey SDK, the code has to implement a class which is inheriting from the SDK Module class. Once a class is created as a subclass of the eGeoffrey's SDK Module class (or its subclasses), it can leverage common functionalities provided by the SDK as well as callbacks which are invoked upon specific events (connected to the gateway, receiving a message, etc.). As a starting point, when developing a module, you have to: Import the Module class or one of its subclasses ( Service , Notification , Controller , Interaction ), depending which module you are targeting to develop Optionally import other suporting classes the SDK provides needed by the module: Message : abstraction of the messages exchanged through the eGeoffrey's message bus Session : session handling to support asyncronous communication Cache : if you need to cache the result of a query Optionally import additional supporting utilities provided by the SDK: Command : for running operating system command DateTimeUtils : common functions for date and time conversion and elaboration Exceptions : for exception handling Numbers : common functions to manipulate numbers Strings : common functions to manipulate strings Web : common functions to interact with web services Implement the Module 's class callbacks accordingly List of functionalities and callbacks . Importing SDK files in Python If you need to import a SDK class: from sdk.python.module.service import Service If you need to import static SDK utilities functions: import sdk.python.utils.web Importing SDK files in Javascript If you need to import any SDK files you need to include the file within the <head> HTML tag: <script src=\"sdk/javascript/module/module.js\"></script> <script src=\"sdk/javascript/utils/strings.js\"></script> Using SDK Images To make eGeoffrey code running consistent across different platforms and prevent discrepancies introduced by missing or wrong dependencies, in eGeoffrey, what eventually the end user runs is a set of Docker images, one for each installed package. To speed up the building process, the eGeoffrey SDK provides also a pre-built docker runtime environment developers should leverage for packaging their own modules. These base docker images, from which you can derive yours, already includes the SDK and all its required dependencies. Furthermore, provide the following functionalities: Include already any operating system and Python requirements for running the SDK Start the an eGeoffrey watchdog service by running python -m sdk.python.module.start The following SDK docker images are available: egeoffrey-sdk-alpine : light-weighted image based on Linux Alpine egeoffrey-sdk-raspbian : an image based on raspbian useful for leveraging Raspberry Pi functionalities Developers can use the one which fits best their requirements. Usually, if no Raspberry Pi specific requirements are needed (e.g. GPIO), go with the eGeoffrey SDK alpine-based image. SDK images follow the same naming convention of any other image egeoffrey-sdk-<os>:<branch>-<architecture> .","title":"Using the SDK"},{"location":"sdk/use/#developing-against-the-sdk","text":"To leverage the SDK, this has to be accessible by your code. A sdk directory from the eGeoffrey SDK repository is expected to be in the root directory of the package. It includes the SDK for all the supported languages. When using eGeoffrey SDK pre-built runtime images, this action is not needed since the SDK and all its required dependencies are already included. To fully leverage eGeoffrey SDK, the code has to implement a class which is inheriting from the SDK Module class. Once a class is created as a subclass of the eGeoffrey's SDK Module class (or its subclasses), it can leverage common functionalities provided by the SDK as well as callbacks which are invoked upon specific events (connected to the gateway, receiving a message, etc.). As a starting point, when developing a module, you have to: Import the Module class or one of its subclasses ( Service , Notification , Controller , Interaction ), depending which module you are targeting to develop Optionally import other suporting classes the SDK provides needed by the module: Message : abstraction of the messages exchanged through the eGeoffrey's message bus Session : session handling to support asyncronous communication Cache : if you need to cache the result of a query Optionally import additional supporting utilities provided by the SDK: Command : for running operating system command DateTimeUtils : common functions for date and time conversion and elaboration Exceptions : for exception handling Numbers : common functions to manipulate numbers Strings : common functions to manipulate strings Web : common functions to interact with web services Implement the Module 's class callbacks accordingly List of functionalities and callbacks .","title":"Developing against the SDK"},{"location":"sdk/use/#importing-sdk-files-in-python","text":"If you need to import a SDK class: from sdk.python.module.service import Service If you need to import static SDK utilities functions: import sdk.python.utils.web","title":"Importing SDK files in Python"},{"location":"sdk/use/#importing-sdk-files-in-javascript","text":"If you need to import any SDK files you need to include the file within the <head> HTML tag: <script src=\"sdk/javascript/module/module.js\"></script> <script src=\"sdk/javascript/utils/strings.js\"></script>","title":"Importing SDK files in Javascript"},{"location":"sdk/use/#using-sdk-images","text":"To make eGeoffrey code running consistent across different platforms and prevent discrepancies introduced by missing or wrong dependencies, in eGeoffrey, what eventually the end user runs is a set of Docker images, one for each installed package. To speed up the building process, the eGeoffrey SDK provides also a pre-built docker runtime environment developers should leverage for packaging their own modules. These base docker images, from which you can derive yours, already includes the SDK and all its required dependencies. Furthermore, provide the following functionalities: Include already any operating system and Python requirements for running the SDK Start the an eGeoffrey watchdog service by running python -m sdk.python.module.start The following SDK docker images are available: egeoffrey-sdk-alpine : light-weighted image based on Linux Alpine egeoffrey-sdk-raspbian : an image based on raspbian useful for leveraging Raspberry Pi functionalities Developers can use the one which fits best their requirements. Usually, if no Raspberry Pi specific requirements are needed (e.g. GPIO), go with the eGeoffrey SDK alpine-based image. SDK images follow the same naming convention of any other image egeoffrey-sdk-<os>:<branch>-<architecture> .","title":"Using SDK Images"},{"location":"sdk/classes/cache/","text":"The Cache Class Python SDK Especially when developing a service , there are cases when you need to cache a result of a query and retrieve it if the same data is requested in a short while. For example, there are weather API services which allow up to a limited number of queries every minute/hour so you don't want to overcome the limit when e.g. requesting multiple information (like temperature, pressure, humidity, etc.) resuting however in the same api call repeated multiple times. The following functions are provided: add(key, value, expire=60) : add key=value in the cache and set expiration time in seconds find(key) : check if key is in the cache and not expired get(key) : get value associated to key from the cache","title":"Cache"},{"location":"sdk/classes/cache/#the-cache-class","text":"Python SDK Especially when developing a service , there are cases when you need to cache a result of a query and retrieve it if the same data is requested in a short while. For example, there are weather API services which allow up to a limited number of queries every minute/hour so you don't want to overcome the limit when e.g. requesting multiple information (like temperature, pressure, humidity, etc.) resuting however in the same api call repeated multiple times. The following functions are provided: add(key, value, expire=60) : add key=value in the cache and set expiration time in seconds find(key) : check if key is in the cache and not expired get(key) : get value associated to key from the cache","title":"The Cache Class"},{"location":"sdk/classes/message/","text":"The Message Class Python SDK, Javascript SDK To provide an abstraction of the information exchanged in the bus without requiring the developer to deal with topics and messages' payload, any message received or sent is represented as a Message object. The following information are directly accessible for each instance of Message : message.topic : topic from which the message comes from, populated only for incoming messages message.house_id : house id message.sender : sender module message.recipient : recipient module message.command : requested command to execute message.args : arguments of the command message.config_schema : version of the schema of configuration file (if a configuration) message.is_null : set to true when payload is null (e.g. deleted configuration file) The information above are automatically populated by the SDK when receiving a new message from the message bus or by the developer when sending out a new message. Additionally, the following functions are provided: reset() : reset the message clear() : clear the payload only parse(topic, payload, retain) : parse MQTT message (topic and payload) set_data(value) : set the payload to value (value can be of any type, e.g. string, dict, etc.) set(key, value) : set key of the payload to value set_null() : set the payload to null get(key) : get the value of key of the payload has(key) : return true if payload has the given key get_data() : get the value of the payload get_request_id() : get the request_id reply() : reply to this message forward(recipient) : forward this message to another module dump() : print out the content of this message","title":"Message"},{"location":"sdk/classes/message/#the-message-class","text":"Python SDK, Javascript SDK To provide an abstraction of the information exchanged in the bus without requiring the developer to deal with topics and messages' payload, any message received or sent is represented as a Message object. The following information are directly accessible for each instance of Message : message.topic : topic from which the message comes from, populated only for incoming messages message.house_id : house id message.sender : sender module message.recipient : recipient module message.command : requested command to execute message.args : arguments of the command message.config_schema : version of the schema of configuration file (if a configuration) message.is_null : set to true when payload is null (e.g. deleted configuration file) The information above are automatically populated by the SDK when receiving a new message from the message bus or by the developer when sending out a new message. Additionally, the following functions are provided: reset() : reset the message clear() : clear the payload only parse(topic, payload, retain) : parse MQTT message (topic and payload) set_data(value) : set the payload to value (value can be of any type, e.g. string, dict, etc.) set(key, value) : set key of the payload to value set_null() : set the payload to null get(key) : get the value of key of the payload has(key) : return true if payload has the given key get_data() : get the value of the payload get_request_id() : get the request_id reply() : reply to this message forward(recipient) : forward this message to another module dump() : print out the content of this message","title":"The Message Class"},{"location":"sdk/classes/module/","text":"The Module Class Python SDK, Javascript SDK To let developers focusing on creating useful modules and beautiful contents, the eGoffrey SDK is intended to make available any capability which could be common among modules in the Module class. Just to name only a few, the following key functionalities are provided by the Module class: takes care of connecting to the eGeoffrey gateway provides a framework of callbacks to allow developers to react upon connection, discussion, starting, stopping, etc. provides common functionalities for communicating with other modules by publishing and receiving messages through the bus implements local and remote logging capabilities provides ad-hoc, specialized subclasses you can inherit from for each type of module and specifically: A Controller class for controller modules An Interaction class for interaction modules A Notification class for notification modules which takes care of retrieving the module's configuration and receiving NOTIFY messages from the alerter so to invoke the callback on_notify() based on the user's configuration A Service class for service modules which takes care of registering \"push\" sensors and scheduling \"pull\" sensors according to their configuration Callbacks When developing a new module and inhering from one of Module 's subclasses, the following callbacks are made available: on_init() : what to do when initializing (subclass has to implement) on_connect() : what to do just after connecting to the gateway on_start() : what to do when start running - after receiving required configuration files if any (subclass has to implement) on_stop() : what to do when shutting down (subclass has to implement) on_disconnect() : what to do just after disconnecting from the gateway on_message(message) : what to do when receiving a new message (subclass has to implement) on_configuration() : what to do when receiving a new/updated configuration (subclass has to implement) Functions The following functions are also provided when inhering from one of Module 's subclasses: add_configuration_listener(args, version=None, wait_for_it=False) : add a listener for the given configuration request (will call on_configuration()) add_request_listener(from_module, command, args) : add a listener for the messages addressed to this module (will call on_message()) add_broadcast_listener(from_module, command, args) : add a listener for broadcasted messages from the given module (will call on_message()) add_manifest_listener(self, from_module=\"+/+\") : add a listner for broadcasted manifests (will call on_message()) add_inspection_listener(from_module, to_module, command, args) : add a listener for intercepting messages from a given module to a given module (will call on_message()) remove_listener(topic) : remove a topic previously subscribed send(message) : send a message to another module log_debug(text) / log_info(text) / log_warning(text) / log_error(text) : log a message is_valid_configuration(settings, configuration) : ensure all the items of an array of settings are included in the configuration object provided sleep(seconds) : wrap around time sleep so to break if the module is stopping upgrade_config(filename, from_version, to_version, content) : upgrade a configuration file to the given version","title":"Module"},{"location":"sdk/classes/module/#the-module-class","text":"Python SDK, Javascript SDK To let developers focusing on creating useful modules and beautiful contents, the eGoffrey SDK is intended to make available any capability which could be common among modules in the Module class. Just to name only a few, the following key functionalities are provided by the Module class: takes care of connecting to the eGeoffrey gateway provides a framework of callbacks to allow developers to react upon connection, discussion, starting, stopping, etc. provides common functionalities for communicating with other modules by publishing and receiving messages through the bus implements local and remote logging capabilities provides ad-hoc, specialized subclasses you can inherit from for each type of module and specifically: A Controller class for controller modules An Interaction class for interaction modules A Notification class for notification modules which takes care of retrieving the module's configuration and receiving NOTIFY messages from the alerter so to invoke the callback on_notify() based on the user's configuration A Service class for service modules which takes care of registering \"push\" sensors and scheduling \"pull\" sensors according to their configuration","title":"The Module Class"},{"location":"sdk/classes/module/#callbacks","text":"When developing a new module and inhering from one of Module 's subclasses, the following callbacks are made available: on_init() : what to do when initializing (subclass has to implement) on_connect() : what to do just after connecting to the gateway on_start() : what to do when start running - after receiving required configuration files if any (subclass has to implement) on_stop() : what to do when shutting down (subclass has to implement) on_disconnect() : what to do just after disconnecting from the gateway on_message(message) : what to do when receiving a new message (subclass has to implement) on_configuration() : what to do when receiving a new/updated configuration (subclass has to implement)","title":"Callbacks"},{"location":"sdk/classes/module/#functions","text":"The following functions are also provided when inhering from one of Module 's subclasses: add_configuration_listener(args, version=None, wait_for_it=False) : add a listener for the given configuration request (will call on_configuration()) add_request_listener(from_module, command, args) : add a listener for the messages addressed to this module (will call on_message()) add_broadcast_listener(from_module, command, args) : add a listener for broadcasted messages from the given module (will call on_message()) add_manifest_listener(self, from_module=\"+/+\") : add a listner for broadcasted manifests (will call on_message()) add_inspection_listener(from_module, to_module, command, args) : add a listener for intercepting messages from a given module to a given module (will call on_message()) remove_listener(topic) : remove a topic previously subscribed send(message) : send a message to another module log_debug(text) / log_info(text) / log_warning(text) / log_error(text) : log a message is_valid_configuration(settings, configuration) : ensure all the items of an array of settings are included in the configuration object provided sleep(seconds) : wrap around time sleep so to break if the module is stopping upgrade_config(filename, from_version, to_version, content) : upgrade a configuration file to the given version","title":"Functions"},{"location":"sdk/classes/mqtt_client/","text":"The Mqtt_client Class Python SDK, Javascript SDK The Mqtt_client class takes care entirely of the communication of the module on the message bus by connecting to it, receiving and sending messages, reconnecting if the connection drops, etc. Developers don't need to interact with Mqtt_client directly; this is part of Module which provides an additional abstraction The following functions are provided: publish(house_id, to_module, command, args, payload_data, retain=false) : publish payload to a given topic (queue the message while offline) unsubscribe(topic) : unsubscribe from a topic start() : connect to the MQTT broker and subscribed to the requested topics add_listener(from_module, to_module, command, filter, wait_for_it) : add a listener for the given request add_configuration_listener(self, house_id, args, wait_for_it) : add a listener for a given configuration stop() : disconnect from the MQTT broker","title":"Mqtt_client"},{"location":"sdk/classes/mqtt_client/#the-mqtt_client-class","text":"Python SDK, Javascript SDK The Mqtt_client class takes care entirely of the communication of the module on the message bus by connecting to it, receiving and sending messages, reconnecting if the connection drops, etc. Developers don't need to interact with Mqtt_client directly; this is part of Module which provides an additional abstraction The following functions are provided: publish(house_id, to_module, command, args, payload_data, retain=false) : publish payload to a given topic (queue the message while offline) unsubscribe(topic) : unsubscribe from a topic start() : connect to the MQTT broker and subscribed to the requested topics add_listener(from_module, to_module, command, filter, wait_for_it) : add a listener for the given request add_configuration_listener(self, house_id, args, wait_for_it) : add a listener for a given configuration stop() : disconnect from the MQTT broker","title":"The Mqtt_client Class"},{"location":"sdk/classes/scheduler/","text":"The Scheduler Class Python SDK Several eGeoffrey components need to run specific tasks recurrently or at a given time. For this reason, an abstraction of the Python ApScheduler class is provided through a Scheduler class. Developers don't need to leverage the Scheduler class directly. This is mainly used by eGeoffrey's controller modules as well as by the `Service` class for scheduling sensors' poll actions on your behalf The following functions are provided: start() : start the scheduler (otherwise will be added at the first job submission stop() : stop the scheduler add_job(job) : schedule a new job (job is a dict in the apscheduler format). Returns the job_id remove_job(job_id) : unschedule a job previously scheduled with add_job","title":"Scheduler"},{"location":"sdk/classes/scheduler/#the-scheduler-class","text":"Python SDK Several eGeoffrey components need to run specific tasks recurrently or at a given time. For this reason, an abstraction of the Python ApScheduler class is provided through a Scheduler class. Developers don't need to leverage the Scheduler class directly. This is mainly used by eGeoffrey's controller modules as well as by the `Service` class for scheduling sensors' poll actions on your behalf The following functions are provided: start() : start the scheduler (otherwise will be added at the first job submission stop() : stop the scheduler add_job(job) : schedule a new job (job is a dict in the apscheduler format). Returns the job_id remove_job(job_id) : unschedule a job previously scheduled with add_job","title":"The Scheduler Class"},{"location":"sdk/classes/session/","text":"The Session Class Python SDK, Javascript SDK Communicating through a message bus introduce additional complexity since the response is asynchronous and not linked with a specific request (like instead could be a REST API call). To help developers in matching a response with a previously sent request, the Session class keeps track of session information (e.g. whatever attribute you need to save) when communicating with other modules. This leverages a a random request_id which is automatically generated by the SDK when creating a new Message object. The following functions are provided: register(message, session) : associate the request_id of a message with a session content restore(message) : return session's content previously saved of a an incoming message (be leveraging the associated request_id) is_registered(message) : return true if this is a registered session, false otherwise","title":"Session"},{"location":"sdk/classes/session/#the-session-class","text":"Python SDK, Javascript SDK Communicating through a message bus introduce additional complexity since the response is asynchronous and not linked with a specific request (like instead could be a REST API call). To help developers in matching a response with a previously sent request, the Session class keeps track of session information (e.g. whatever attribute you need to save) when communicating with other modules. This leverages a a random request_id which is automatically generated by the SDK when creating a new Message object. The following functions are provided: register(message, session) : associate the request_id of a message with a session content restore(message) : return session's content previously saved of a an incoming message (be leveraging the associated request_id) is_registered(message) : return true if this is a registered session, false otherwise","title":"The Session Class"},{"location":"sdk/utils/command/","text":"The Command Util Python SDK Allow running a given operating system command. The following functions are provided: run(command, shell=True, background=False) : run a command and return the output","title":"Command"},{"location":"sdk/utils/command/#the-command-util","text":"Python SDK Allow running a given operating system command. The following functions are provided: run(command, shell=True, background=False) : run a command and return the output","title":"The Command Util"},{"location":"sdk/utils/datetimeutils/","text":"The DateTimeUtils Util Python SDK, Javascript SDK Provide a number of functions to do date and time conversion and elaboration. DateTimeUtils is a class which has to be initialized with the local timezone offset. The Python and Javascript SDKs provide different functions. The following common functions are provided: timezone(timestamp) : return the timestamp with the timezone offset applied utc(timestamp) : return an UTC timestamp from a given timestamp (in the local timezone) now() : return the now timestamp (in the current timezone) Python yesterday : return yesterday's timestamp from a given timestamp (in the local timezone) last_hour : return the last hour timestamp from a given timestamp (in the local timezone) get_timestamp(years, months, days, hours, minutes, seconds) : generate a UTC timestamp based on the input day_start(timestamp) : return day start timestamp from a given timestamp (in the local timezone) day_end(timestamp) : return day end timestamp from a given timestamp (in the local timezone) hour_start(timestamp) : return hour start timestamp from a given timestamp (in the local timezone) hour_end(timestamp) : return hour end timestamp from a given timestamp (in the local timezone) timestamp2date(timestamp) : take a timestamp (in the local timezone) and return it in a human-readable format Javascript format_timestamp(timestamp=this.now()) : format the provided timestamp for printing timestamp_difference(date1, date2) : return the difference between two timestamps in a human readable format","title":"DateTimeUtils"},{"location":"sdk/utils/datetimeutils/#the-datetimeutils-util","text":"Python SDK, Javascript SDK Provide a number of functions to do date and time conversion and elaboration. DateTimeUtils is a class which has to be initialized with the local timezone offset. The Python and Javascript SDKs provide different functions. The following common functions are provided: timezone(timestamp) : return the timestamp with the timezone offset applied utc(timestamp) : return an UTC timestamp from a given timestamp (in the local timezone) now() : return the now timestamp (in the current timezone)","title":"The DateTimeUtils Util"},{"location":"sdk/utils/datetimeutils/#python","text":"yesterday : return yesterday's timestamp from a given timestamp (in the local timezone) last_hour : return the last hour timestamp from a given timestamp (in the local timezone) get_timestamp(years, months, days, hours, minutes, seconds) : generate a UTC timestamp based on the input day_start(timestamp) : return day start timestamp from a given timestamp (in the local timezone) day_end(timestamp) : return day end timestamp from a given timestamp (in the local timezone) hour_start(timestamp) : return hour start timestamp from a given timestamp (in the local timezone) hour_end(timestamp) : return hour end timestamp from a given timestamp (in the local timezone) timestamp2date(timestamp) : take a timestamp (in the local timezone) and return it in a human-readable format","title":"Python"},{"location":"sdk/utils/datetimeutils/#javascript","text":"format_timestamp(timestamp=this.now()) : format the provided timestamp for printing timestamp_difference(date1, date2) : return the difference between two timestamps in a human readable format","title":"Javascript"},{"location":"sdk/utils/exceptions/","text":"The Exceptions Util Python SDK The following common functions are provided: get(e) : return the exception as a single-line string","title":"Exceptions"},{"location":"sdk/utils/exceptions/#the-exceptions-util","text":"Python SDK The following common functions are provided: get(e) : return the exception as a single-line string","title":"The Exceptions Util"},{"location":"sdk/utils/numbers/","text":"The Numbers Util Python SDK Provide functions to manipulate numbers. The following common functions are provided: is_number(s) : return true if the input is a number normalize(value, format=None) : normalize the value based on the given format. If the input is a number, keep a single digit, otherwise return a string remove_all(array, value_array) : remove all occurrences of value from array min(data) : calculate the min of a given array of data max(data) : calculate the max of a given array of data avg(data) : calculate the avg of a given array of data sum(data) : calculate the sum of a given array of data count(data) : count the items of a given array of data count_unique(data) : count the (unique) items of a given array of data randint(min,max) : return a random int between min and max hex2int(hex) : convert a hex string into an integer","title":"Numbers"},{"location":"sdk/utils/numbers/#the-numbers-util","text":"Python SDK Provide functions to manipulate numbers. The following common functions are provided: is_number(s) : return true if the input is a number normalize(value, format=None) : normalize the value based on the given format. If the input is a number, keep a single digit, otherwise return a string remove_all(array, value_array) : remove all occurrences of value from array min(data) : calculate the min of a given array of data max(data) : calculate the max of a given array of data avg(data) : calculate the avg of a given array of data sum(data) : calculate the sum of a given array of data count(data) : count the items of a given array of data count_unique(data) : count the (unique) items of a given array of data randint(min,max) : return a random int between min and max hex2int(hex) : convert a hex string into an integer","title":"The Numbers Util"},{"location":"sdk/utils/strings/","text":"The Strings Util Python SDK, Javascript SDK Provide a number of functions to manipulate strings. The Python and Javascript SDKs provide different functions. The following common functions are provided: truncate(string, max_len=50) : truncate a long string format_log_line(severity, module, text) : format a log line for printing Python hex2string(hex) : convert a hex string into a ascii string Javascript capitalizeFirst(string) : capitalize the first letter replaceAll(search, replacement) : replace all instances of search in replacement get_exception(e) : return stack trace exception topic_matches_sub(pattern, topic) : javascript implementation of topic_matches_sub format_multiline(string, length) : format a multiline string by enforcing a maximum length escape_html(string) : escape html special characters in a string","title":"Strings"},{"location":"sdk/utils/strings/#the-strings-util","text":"Python SDK, Javascript SDK Provide a number of functions to manipulate strings. The Python and Javascript SDKs provide different functions. The following common functions are provided: truncate(string, max_len=50) : truncate a long string format_log_line(severity, module, text) : format a log line for printing","title":"The Strings Util"},{"location":"sdk/utils/strings/#python","text":"hex2string(hex) : convert a hex string into a ascii string","title":"Python"},{"location":"sdk/utils/strings/#javascript","text":"capitalizeFirst(string) : capitalize the first letter replaceAll(search, replacement) : replace all instances of search in replacement get_exception(e) : return stack trace exception topic_matches_sub(pattern, topic) : javascript implementation of topic_matches_sub format_multiline(string, length) : format a multiline string by enforcing a maximum length escape_html(string) : escape html special characters in a string","title":"Javascript"},{"location":"sdk/utils/web/","text":"The Web Util Python SDK Provide a way for requesting a web page The following functions are provided: get(url,username=None,password=None,binary=False,params={},timeout=30) : request a given url and returns its content","title":"Web"},{"location":"sdk/utils/web/#the-web-util","text":"Python SDK Provide a way for requesting a web page The following functions are provided: get(url,username=None,password=None,binary=False,params={},timeout=30) : request a given url and returns its content","title":"The Web Util"}]}